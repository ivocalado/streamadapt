// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <policy/policy.h>

namespace AdaptationPolicy
{
  // PolicyConfigurationType
  //

  const PolicyConfigurationType::policy_name_type& PolicyConfigurationType::
  policy_name () const
  {
    return this->policy_name_.get ();
  }

  PolicyConfigurationType::policy_name_type& PolicyConfigurationType::
  policy_name ()
  {
    return this->policy_name_.get ();
  }

  void PolicyConfigurationType::
  policy_name (const policy_name_type& x)
  {
    this->policy_name_.set (x);
  }

  void PolicyConfigurationType::
  policy_name (::std::auto_ptr< policy_name_type > x)
  {
    this->policy_name_.set (x);
  }

  const PolicyConfigurationType::policy_description_type& PolicyConfigurationType::
  policy_description () const
  {
    return this->policy_description_.get ();
  }

  PolicyConfigurationType::policy_description_type& PolicyConfigurationType::
  policy_description ()
  {
    return this->policy_description_.get ();
  }

  void PolicyConfigurationType::
  policy_description (const policy_description_type& x)
  {
    this->policy_description_.set (x);
  }

  void PolicyConfigurationType::
  policy_description (::std::auto_ptr< policy_description_type > x)
  {
    this->policy_description_.set (x);
  }

  const PolicyConfigurationType::startup_config_type& PolicyConfigurationType::
  startup_config () const
  {
    return this->startup_config_.get ();
  }

  PolicyConfigurationType::startup_config_type& PolicyConfigurationType::
  startup_config ()
  {
    return this->startup_config_.get ();
  }

  void PolicyConfigurationType::
  startup_config (const startup_config_type& x)
  {
    this->startup_config_.set (x);
  }

  void PolicyConfigurationType::
  startup_config (::std::auto_ptr< startup_config_type > x)
  {
    this->startup_config_.set (x);
  }

  const PolicyConfigurationType::adapt_config_optional& PolicyConfigurationType::
  adapt_config () const
  {
    return this->adapt_config_;
  }

  PolicyConfigurationType::adapt_config_optional& PolicyConfigurationType::
  adapt_config ()
  {
    return this->adapt_config_;
  }

  void PolicyConfigurationType::
  adapt_config (const adapt_config_type& x)
  {
    this->adapt_config_.set (x);
  }

  void PolicyConfigurationType::
  adapt_config (const adapt_config_optional& x)
  {
    this->adapt_config_ = x;
  }

  void PolicyConfigurationType::
  adapt_config (::std::auto_ptr< adapt_config_type > x)
  {
    this->adapt_config_.set (x);
  }


  // PolicyType
  //

  const PolicyType::comparisson_attibute_type& PolicyType::
  comparisson_attibute () const
  {
    return this->comparisson_attibute_.get ();
  }

  PolicyType::comparisson_attibute_type& PolicyType::
  comparisson_attibute ()
  {
    return this->comparisson_attibute_.get ();
  }

  void PolicyType::
  comparisson_attibute (const comparisson_attibute_type& x)
  {
    this->comparisson_attibute_.set (x);
  }

  void PolicyType::
  comparisson_attibute (::std::auto_ptr< comparisson_attibute_type > x)
  {
    this->comparisson_attibute_.set (x);
  }

  const PolicyType::unit_type& PolicyType::
  unit () const
  {
    return this->unit_.get ();
  }

  PolicyType::unit_type& PolicyType::
  unit ()
  {
    return this->unit_.get ();
  }

  void PolicyType::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void PolicyType::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const PolicyType::lower_optional& PolicyType::
  lower () const
  {
    return this->lower_;
  }

  PolicyType::lower_optional& PolicyType::
  lower ()
  {
    return this->lower_;
  }

  void PolicyType::
  lower (const lower_type& x)
  {
    this->lower_.set (x);
  }

  void PolicyType::
  lower (const lower_optional& x)
  {
    this->lower_ = x;
  }

  void PolicyType::
  lower (::std::auto_ptr< lower_type > x)
  {
    this->lower_.set (x);
  }

  const PolicyType::range_sequence& PolicyType::
  range () const
  {
    return this->range_;
  }

  PolicyType::range_sequence& PolicyType::
  range ()
  {
    return this->range_;
  }

  void PolicyType::
  range (const range_sequence& s)
  {
    this->range_ = s;
  }

  const PolicyType::greater_optional& PolicyType::
  greater () const
  {
    return this->greater_;
  }

  PolicyType::greater_optional& PolicyType::
  greater ()
  {
    return this->greater_;
  }

  void PolicyType::
  greater (const greater_type& x)
  {
    this->greater_.set (x);
  }

  void PolicyType::
  greater (const greater_optional& x)
  {
    this->greater_ = x;
  }

  void PolicyType::
  greater (::std::auto_ptr< greater_type > x)
  {
    this->greater_.set (x);
  }


  // ComplexPropertyType
  //

  const ComplexPropertyType::sub_property_sequence& ComplexPropertyType::
  sub_property () const
  {
    return this->sub_property_;
  }

  ComplexPropertyType::sub_property_sequence& ComplexPropertyType::
  sub_property ()
  {
    return this->sub_property_;
  }

  void ComplexPropertyType::
  sub_property (const sub_property_sequence& s)
  {
    this->sub_property_ = s;
  }

  const ComplexPropertyType::key_type& ComplexPropertyType::
  key () const
  {
    return this->key_.get ();
  }

  ComplexPropertyType::key_type& ComplexPropertyType::
  key ()
  {
    return this->key_.get ();
  }

  void ComplexPropertyType::
  key (const key_type& x)
  {
    this->key_.set (x);
  }

  void ComplexPropertyType::
  key (::std::auto_ptr< key_type > x)
  {
    this->key_.set (x);
  }


  // SimplePropertyType
  //

  const SimplePropertyType::key_type& SimplePropertyType::
  key () const
  {
    return this->key_.get ();
  }

  SimplePropertyType::key_type& SimplePropertyType::
  key ()
  {
    return this->key_.get ();
  }

  void SimplePropertyType::
  key (const key_type& x)
  {
    this->key_.set (x);
  }

  void SimplePropertyType::
  key (::std::auto_ptr< key_type > x)
  {
    this->key_.set (x);
  }


  // IFType
  //

  const IFType::equals_sequence& IFType::
  equals () const
  {
    return this->equals_;
  }

  IFType::equals_sequence& IFType::
  equals ()
  {
    return this->equals_;
  }

  void IFType::
  equals (const equals_sequence& s)
  {
    this->equals_ = s;
  }

  const IFType::lower_sequence& IFType::
  lower () const
  {
    return this->lower_;
  }

  IFType::lower_sequence& IFType::
  lower ()
  {
    return this->lower_;
  }

  void IFType::
  lower (const lower_sequence& s)
  {
    this->lower_ = s;
  }

  const IFType::greater_sequence& IFType::
  greater () const
  {
    return this->greater_;
  }

  IFType::greater_sequence& IFType::
  greater ()
  {
    return this->greater_;
  }

  void IFType::
  greater (const greater_sequence& s)
  {
    this->greater_ = s;
  }

  const IFType::operations_type& IFType::
  operations () const
  {
    return this->operations_.get ();
  }

  IFType::operations_type& IFType::
  operations ()
  {
    return this->operations_.get ();
  }

  void IFType::
  operations (const operations_type& x)
  {
    this->operations_.set (x);
  }

  void IFType::
  operations (::std::auto_ptr< operations_type > x)
  {
    this->operations_.set (x);
  }


  // ProviderType
  //

  const ProviderType::default_value_type& ProviderType::
  default_value () const
  {
    return this->default_value_.get ();
  }

  ProviderType::default_value_type& ProviderType::
  default_value ()
  {
    return this->default_value_.get ();
  }

  void ProviderType::
  default_value (const default_value_type& x)
  {
    this->default_value_.set (x);
  }

  const ProviderType::update_time_type& ProviderType::
  update_time () const
  {
    return this->update_time_.get ();
  }

  ProviderType::update_time_type& ProviderType::
  update_time ()
  {
    return this->update_time_.get ();
  }

  void ProviderType::
  update_time (const update_time_type& x)
  {
    this->update_time_.set (x);
  }

  const ProviderType::update_time_type& ProviderType::
  update_time_default_value ()
  {
    return update_time_default_value_;
  }


  // startup_config
  //

  const startup_config::negotiation_type& startup_config::
  negotiation () const
  {
    return this->negotiation_.get ();
  }

  startup_config::negotiation_type& startup_config::
  negotiation ()
  {
    return this->negotiation_.get ();
  }

  void startup_config::
  negotiation (const negotiation_type& x)
  {
    this->negotiation_.set (x);
  }

  void startup_config::
  negotiation (::std::auto_ptr< negotiation_type > x)
  {
    this->negotiation_.set (x);
  }

  const startup_config::transport_type& startup_config::
  transport () const
  {
    return this->transport_.get ();
  }

  startup_config::transport_type& startup_config::
  transport ()
  {
    return this->transport_.get ();
  }

  void startup_config::
  transport (const transport_type& x)
  {
    this->transport_.set (x);
  }

  void startup_config::
  transport (::std::auto_ptr< transport_type > x)
  {
    this->transport_.set (x);
  }

  const startup_config::stream_type& startup_config::
  stream () const
  {
    return this->stream_.get ();
  }

  startup_config::stream_type& startup_config::
  stream ()
  {
    return this->stream_.get ();
  }

  void startup_config::
  stream (const stream_type& x)
  {
    this->stream_.set (x);
  }

  void startup_config::
  stream (::std::auto_ptr< stream_type > x)
  {
    this->stream_.set (x);
  }


  // adapt_config
  //

  const adapt_config::stream_optional& adapt_config::
  stream () const
  {
    return this->stream_;
  }

  adapt_config::stream_optional& adapt_config::
  stream ()
  {
    return this->stream_;
  }

  void adapt_config::
  stream (const stream_type& x)
  {
    this->stream_.set (x);
  }

  void adapt_config::
  stream (const stream_optional& x)
  {
    this->stream_ = x;
  }

  void adapt_config::
  stream (::std::auto_ptr< stream_type > x)
  {
    this->stream_.set (x);
  }

  const adapt_config::transport_optional& adapt_config::
  transport () const
  {
    return this->transport_;
  }

  adapt_config::transport_optional& adapt_config::
  transport ()
  {
    return this->transport_;
  }

  void adapt_config::
  transport (const transport_type& x)
  {
    this->transport_.set (x);
  }

  void adapt_config::
  transport (const transport_optional& x)
  {
    this->transport_ = x;
  }

  void adapt_config::
  transport (::std::auto_ptr< transport_type > x)
  {
    this->transport_.set (x);
  }


  // comparisson_attibute
  //


  // unit
  //


  // lower
  //

  const lower::complexproperty_sequence& lower::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  lower::complexproperty_sequence& lower::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void lower::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }

  const lower::simpleproperty_sequence& lower::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  lower::simpleproperty_sequence& lower::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void lower::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }

  const lower::if_sequence& lower::
  if_ () const
  {
    return this->if__;
  }

  lower::if_sequence& lower::
  if_ ()
  {
    return this->if__;
  }

  void lower::
  if_ (const if_sequence& s)
  {
    this->if__ = s;
  }

  const lower::threshold_type& lower::
  threshold () const
  {
    return this->threshold_.get ();
  }

  lower::threshold_type& lower::
  threshold ()
  {
    return this->threshold_.get ();
  }

  void lower::
  threshold (const threshold_type& x)
  {
    this->threshold_.set (x);
  }


  // range
  //

  const range::complexproperty_sequence& range::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  range::complexproperty_sequence& range::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void range::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }

  const range::simpleproperty_sequence& range::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  range::simpleproperty_sequence& range::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void range::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }

  const range::if_sequence& range::
  if_ () const
  {
    return this->if__;
  }

  range::if_sequence& range::
  if_ ()
  {
    return this->if__;
  }

  void range::
  if_ (const if_sequence& s)
  {
    this->if__ = s;
  }

  const range::from_type& range::
  from () const
  {
    return this->from_.get ();
  }

  range::from_type& range::
  from ()
  {
    return this->from_.get ();
  }

  void range::
  from (const from_type& x)
  {
    this->from_.set (x);
  }

  const range::to_type& range::
  to () const
  {
    return this->to_.get ();
  }

  range::to_type& range::
  to ()
  {
    return this->to_.get ();
  }

  void range::
  to (const to_type& x)
  {
    this->to_.set (x);
  }


  // greater
  //

  const greater::complexproperty_sequence& greater::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  greater::complexproperty_sequence& greater::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void greater::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }

  const greater::simpleproperty_sequence& greater::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  greater::simpleproperty_sequence& greater::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void greater::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }

  const greater::if_sequence& greater::
  if_ () const
  {
    return this->if__;
  }

  greater::if_sequence& greater::
  if_ ()
  {
    return this->if__;
  }

  void greater::
  if_ (const if_sequence& s)
  {
    this->if__ = s;
  }

  const greater::threshold_type& greater::
  threshold () const
  {
    return this->threshold_.get ();
  }

  greater::threshold_type& greater::
  threshold ()
  {
    return this->threshold_.get ();
  }

  void greater::
  threshold (const threshold_type& x)
  {
    this->threshold_.set (x);
  }


  // key
  //


  // key1
  //


  // equals
  //

  const equals::Lhs_type& equals::
  Lhs () const
  {
    return this->Lhs_.get ();
  }

  equals::Lhs_type& equals::
  Lhs ()
  {
    return this->Lhs_.get ();
  }

  void equals::
  Lhs (const Lhs_type& x)
  {
    this->Lhs_.set (x);
  }

  void equals::
  Lhs (::std::auto_ptr< Lhs_type > x)
  {
    this->Lhs_.set (x);
  }

  const equals::Rhs_type& equals::
  Rhs () const
  {
    return this->Rhs_.get ();
  }

  equals::Rhs_type& equals::
  Rhs ()
  {
    return this->Rhs_.get ();
  }

  void equals::
  Rhs (const Rhs_type& x)
  {
    this->Rhs_.set (x);
  }


  // lower1
  //

  const lower1::Lhs_type& lower1::
  Lhs () const
  {
    return this->Lhs_.get ();
  }

  lower1::Lhs_type& lower1::
  Lhs ()
  {
    return this->Lhs_.get ();
  }

  void lower1::
  Lhs (const Lhs_type& x)
  {
    this->Lhs_.set (x);
  }

  void lower1::
  Lhs (::std::auto_ptr< Lhs_type > x)
  {
    this->Lhs_.set (x);
  }

  const lower1::Rhs_type& lower1::
  Rhs () const
  {
    return this->Rhs_.get ();
  }

  lower1::Rhs_type& lower1::
  Rhs ()
  {
    return this->Rhs_.get ();
  }

  void lower1::
  Rhs (const Rhs_type& x)
  {
    this->Rhs_.set (x);
  }

  const lower1::equals_type& lower1::
  equals () const
  {
    return this->equals_.get ();
  }

  lower1::equals_type& lower1::
  equals ()
  {
    return this->equals_.get ();
  }

  void lower1::
  equals (const equals_type& x)
  {
    this->equals_.set (x);
  }

  const lower1::equals_type& lower1::
  equals_default_value ()
  {
    return equals_default_value_;
  }


  // greater1
  //

  const greater1::Lhs_type& greater1::
  Lhs () const
  {
    return this->Lhs_.get ();
  }

  greater1::Lhs_type& greater1::
  Lhs ()
  {
    return this->Lhs_.get ();
  }

  void greater1::
  Lhs (const Lhs_type& x)
  {
    this->Lhs_.set (x);
  }

  void greater1::
  Lhs (::std::auto_ptr< Lhs_type > x)
  {
    this->Lhs_.set (x);
  }

  const greater1::Rhs_type& greater1::
  Rhs () const
  {
    return this->Rhs_.get ();
  }

  greater1::Rhs_type& greater1::
  Rhs ()
  {
    return this->Rhs_.get ();
  }

  void greater1::
  Rhs (const Rhs_type& x)
  {
    this->Rhs_.set (x);
  }

  const greater1::equals_type& greater1::
  equals () const
  {
    return this->equals_.get ();
  }

  greater1::equals_type& greater1::
  equals ()
  {
    return this->equals_.get ();
  }

  void greater1::
  equals (const equals_type& x)
  {
    this->equals_.set (x);
  }

  const greater1::equals_type& greater1::
  equals_default_value ()
  {
    return equals_default_value_;
  }


  // operations
  //

  const operations::simpleproperty_sequence& operations::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  operations::simpleproperty_sequence& operations::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void operations::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }

  const operations::complexproperty_sequence& operations::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  operations::complexproperty_sequence& operations::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void operations::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }


  // negotiation
  //


  // transport
  //

  const transport::protocol_type& transport::
  protocol () const
  {
    return this->protocol_.get ();
  }

  transport::protocol_type& transport::
  protocol ()
  {
    return this->protocol_.get ();
  }

  void transport::
  protocol (const protocol_type& x)
  {
    this->protocol_.set (x);
  }

  void transport::
  protocol (::std::auto_ptr< protocol_type > x)
  {
    this->protocol_.set (x);
  }

  const transport::plugin_name_type& transport::
  plugin_name () const
  {
    return this->plugin_name_.get ();
  }

  transport::plugin_name_type& transport::
  plugin_name ()
  {
    return this->plugin_name_.get ();
  }

  void transport::
  plugin_name (const plugin_name_type& x)
  {
    this->plugin_name_.set (x);
  }

  void transport::
  plugin_name (::std::auto_ptr< plugin_name_type > x)
  {
    this->plugin_name_.set (x);
  }

  const transport::library_name_type& transport::
  library_name () const
  {
    return this->library_name_.get ();
  }

  transport::library_name_type& transport::
  library_name ()
  {
    return this->library_name_.get ();
  }

  void transport::
  library_name (const library_name_type& x)
  {
    this->library_name_.set (x);
  }

  void transport::
  library_name (::std::auto_ptr< library_name_type > x)
  {
    this->library_name_.set (x);
  }

  const transport::library_directory_optional& transport::
  library_directory () const
  {
    return this->library_directory_;
  }

  transport::library_directory_optional& transport::
  library_directory ()
  {
    return this->library_directory_;
  }

  void transport::
  library_directory (const library_directory_type& x)
  {
    this->library_directory_.set (x);
  }

  void transport::
  library_directory (const library_directory_optional& x)
  {
    this->library_directory_ = x;
  }

  void transport::
  library_directory (::std::auto_ptr< library_directory_type > x)
  {
    this->library_directory_.set (x);
  }

  const transport::enable_adaptation_type& transport::
  enable_adaptation () const
  {
    return this->enable_adaptation_.get ();
  }

  transport::enable_adaptation_type& transport::
  enable_adaptation ()
  {
    return this->enable_adaptation_.get ();
  }

  void transport::
  enable_adaptation (const enable_adaptation_type& x)
  {
    this->enable_adaptation_.set (x);
  }

  const transport::enable_adaptation_type& transport::
  enable_adaptation_default_value ()
  {
    return enable_adaptation_default_value_;
  }

  const transport::provides_optional& transport::
  provides () const
  {
    return this->provides_;
  }

  transport::provides_optional& transport::
  provides ()
  {
    return this->provides_;
  }

  void transport::
  provides (const provides_type& x)
  {
    this->provides_.set (x);
  }

  void transport::
  provides (const provides_optional& x)
  {
    this->provides_ = x;
  }

  void transport::
  provides (::std::auto_ptr< provides_type > x)
  {
    this->provides_.set (x);
  }

  const transport::complexproperty_sequence& transport::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  transport::complexproperty_sequence& transport::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void transport::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }

  const transport::simpleproperty_sequence& transport::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  transport::simpleproperty_sequence& transport::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void transport::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }


  // stream
  //

  const stream::plugin_name_type& stream::
  plugin_name () const
  {
    return this->plugin_name_.get ();
  }

  stream::plugin_name_type& stream::
  plugin_name ()
  {
    return this->plugin_name_.get ();
  }

  void stream::
  plugin_name (const plugin_name_type& x)
  {
    this->plugin_name_.set (x);
  }

  void stream::
  plugin_name (::std::auto_ptr< plugin_name_type > x)
  {
    this->plugin_name_.set (x);
  }

  const stream::library_name_type& stream::
  library_name () const
  {
    return this->library_name_.get ();
  }

  stream::library_name_type& stream::
  library_name ()
  {
    return this->library_name_.get ();
  }

  void stream::
  library_name (const library_name_type& x)
  {
    this->library_name_.set (x);
  }

  void stream::
  library_name (::std::auto_ptr< library_name_type > x)
  {
    this->library_name_.set (x);
  }

  const stream::library_directory_optional& stream::
  library_directory () const
  {
    return this->library_directory_;
  }

  stream::library_directory_optional& stream::
  library_directory ()
  {
    return this->library_directory_;
  }

  void stream::
  library_directory (const library_directory_type& x)
  {
    this->library_directory_.set (x);
  }

  void stream::
  library_directory (const library_directory_optional& x)
  {
    this->library_directory_ = x;
  }

  void stream::
  library_directory (::std::auto_ptr< library_directory_type > x)
  {
    this->library_directory_.set (x);
  }

  const stream::video_transmission_optional& stream::
  video_transmission () const
  {
    return this->video_transmission_;
  }

  stream::video_transmission_optional& stream::
  video_transmission ()
  {
    return this->video_transmission_;
  }

  void stream::
  video_transmission (const video_transmission_type& x)
  {
    this->video_transmission_.set (x);
  }

  void stream::
  video_transmission (const video_transmission_optional& x)
  {
    this->video_transmission_ = x;
  }

  void stream::
  video_transmission (::std::auto_ptr< video_transmission_type > x)
  {
    this->video_transmission_.set (x);
  }

  const stream::audio_transmission_optional& stream::
  audio_transmission () const
  {
    return this->audio_transmission_;
  }

  stream::audio_transmission_optional& stream::
  audio_transmission ()
  {
    return this->audio_transmission_;
  }

  void stream::
  audio_transmission (const audio_transmission_type& x)
  {
    this->audio_transmission_.set (x);
  }

  void stream::
  audio_transmission (const audio_transmission_optional& x)
  {
    this->audio_transmission_ = x;
  }

  void stream::
  audio_transmission (::std::auto_ptr< audio_transmission_type > x)
  {
    this->audio_transmission_.set (x);
  }

  const stream::enable_adaptation_type& stream::
  enable_adaptation () const
  {
    return this->enable_adaptation_.get ();
  }

  stream::enable_adaptation_type& stream::
  enable_adaptation ()
  {
    return this->enable_adaptation_.get ();
  }

  void stream::
  enable_adaptation (const enable_adaptation_type& x)
  {
    this->enable_adaptation_.set (x);
  }

  const stream::enable_adaptation_type& stream::
  enable_adaptation_default_value ()
  {
    return enable_adaptation_default_value_;
  }

  const stream::provides_optional& stream::
  provides () const
  {
    return this->provides_;
  }

  stream::provides_optional& stream::
  provides ()
  {
    return this->provides_;
  }

  void stream::
  provides (const provides_type& x)
  {
    this->provides_.set (x);
  }

  void stream::
  provides (const provides_optional& x)
  {
    this->provides_ = x;
  }

  void stream::
  provides (::std::auto_ptr< provides_type > x)
  {
    this->provides_.set (x);
  }

  const stream::complexproperty_sequence& stream::
  complexproperty () const
  {
    return this->complexproperty_;
  }

  stream::complexproperty_sequence& stream::
  complexproperty ()
  {
    return this->complexproperty_;
  }

  void stream::
  complexproperty (const complexproperty_sequence& s)
  {
    this->complexproperty_ = s;
  }

  const stream::simpleproperty_sequence& stream::
  simpleproperty () const
  {
    return this->simpleproperty_;
  }

  stream::simpleproperty_sequence& stream::
  simpleproperty ()
  {
    return this->simpleproperty_;
  }

  void stream::
  simpleproperty (const simpleproperty_sequence& s)
  {
    this->simpleproperty_ = s;
  }


  // stream1
  //

  const stream1::adaptation_method_type& stream1::
  adaptation_method () const
  {
    return this->adaptation_method_.get ();
  }

  stream1::adaptation_method_type& stream1::
  adaptation_method ()
  {
    return this->adaptation_method_.get ();
  }

  void stream1::
  adaptation_method (const adaptation_method_type& x)
  {
    this->adaptation_method_.set (x);
  }

  void stream1::
  adaptation_method (::std::auto_ptr< adaptation_method_type > x)
  {
    this->adaptation_method_.set (x);
  }

  const stream1::policy_sequence& stream1::
  policy () const
  {
    return this->policy_;
  }

  stream1::policy_sequence& stream1::
  policy ()
  {
    return this->policy_;
  }

  void stream1::
  policy (const policy_sequence& s)
  {
    this->policy_ = s;
  }


  // transport1
  //

  const transport1::adaptation_method_type& transport1::
  adaptation_method () const
  {
    return this->adaptation_method_.get ();
  }

  transport1::adaptation_method_type& transport1::
  adaptation_method ()
  {
    return this->adaptation_method_.get ();
  }

  void transport1::
  adaptation_method (const adaptation_method_type& x)
  {
    this->adaptation_method_.set (x);
  }

  void transport1::
  adaptation_method (::std::auto_ptr< adaptation_method_type > x)
  {
    this->adaptation_method_.set (x);
  }

  const transport1::policy_sequence& transport1::
  policy () const
  {
    return this->policy_;
  }

  transport1::policy_sequence& transport1::
  policy ()
  {
    return this->policy_;
  }

  void transport1::
  policy (const policy_sequence& s)
  {
    this->policy_ = s;
  }


  // protocol
  //


  // plugin_name
  //


  // library_name
  //


  // library_directory
  //


  // provides
  //

  const provides::provide_sequence& provides::
  provide () const
  {
    return this->provide_;
  }

  provides::provide_sequence& provides::
  provide ()
  {
    return this->provide_;
  }

  void provides::
  provide (const provide_sequence& s)
  {
    this->provide_ = s;
  }


  // plugin_name1
  //


  // library_name1
  //


  // library_directory1
  //


  // video_transmission
  //

  const video_transmission::video_codec_type& video_transmission::
  video_codec () const
  {
    return this->video_codec_.get ();
  }

  video_transmission::video_codec_type& video_transmission::
  video_codec ()
  {
    return this->video_codec_.get ();
  }

  void video_transmission::
  video_codec (const video_codec_type& x)
  {
    this->video_codec_.set (x);
  }

  void video_transmission::
  video_codec (::std::auto_ptr< video_codec_type > x)
  {
    this->video_codec_.set (x);
  }


  // audio_transmission
  //

  const audio_transmission::codec_name_type& audio_transmission::
  codec_name () const
  {
    return this->codec_name_.get ();
  }

  audio_transmission::codec_name_type& audio_transmission::
  codec_name ()
  {
    return this->codec_name_.get ();
  }

  void audio_transmission::
  codec_name (const codec_name_type& x)
  {
    this->codec_name_.set (x);
  }

  void audio_transmission::
  codec_name (::std::auto_ptr< codec_name_type > x)
  {
    this->codec_name_.set (x);
  }

  const audio_transmission::enablePreprocessing_type& audio_transmission::
  enablePreprocessing () const
  {
    return this->enablePreprocessing_.get ();
  }

  audio_transmission::enablePreprocessing_type& audio_transmission::
  enablePreprocessing ()
  {
    return this->enablePreprocessing_.get ();
  }

  void audio_transmission::
  enablePreprocessing (const enablePreprocessing_type& x)
  {
    this->enablePreprocessing_.set (x);
  }

  const audio_transmission::enablePreprocessing_type& audio_transmission::
  enablePreprocessing_default_value ()
  {
    return enablePreprocessing_default_value_;
  }

  const audio_transmission::enableEchoCancellation_type& audio_transmission::
  enableEchoCancellation () const
  {
    return this->enableEchoCancellation_.get ();
  }

  audio_transmission::enableEchoCancellation_type& audio_transmission::
  enableEchoCancellation ()
  {
    return this->enableEchoCancellation_.get ();
  }

  void audio_transmission::
  enableEchoCancellation (const enableEchoCancellation_type& x)
  {
    this->enableEchoCancellation_.set (x);
  }

  const audio_transmission::enableEchoCancellation_type& audio_transmission::
  enableEchoCancellation_default_value ()
  {
    return enableEchoCancellation_default_value_;
  }


  // provides1
  //

  const provides1::provide_sequence& provides1::
  provide () const
  {
    return this->provide_;
  }

  provides1::provide_sequence& provides1::
  provide ()
  {
    return this->provide_;
  }

  void provides1::
  provide (const provide_sequence& s)
  {
    this->provide_ = s;
  }


  // adaptation_method
  //


  // adaptation_method1
  //


  // codec_name
  //
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace AdaptationPolicy
{
  // PolicyConfigurationType
  //

  PolicyConfigurationType::
  PolicyConfigurationType (const policy_name_type& policy_name,
                           const policy_description_type& policy_description,
                           const startup_config_type& startup_config)
  : ::xml_schema::type (),
    policy_name_ (policy_name, ::xml_schema::flags (), this),
    policy_description_ (policy_description, ::xml_schema::flags (), this),
    startup_config_ (startup_config, ::xml_schema::flags (), this),
    adapt_config_ (::xml_schema::flags (), this)
  {
  }

  PolicyConfigurationType::
  PolicyConfigurationType (const policy_name_type& policy_name,
                           const policy_description_type& policy_description,
                           ::std::auto_ptr< startup_config_type >& startup_config)
  : ::xml_schema::type (),
    policy_name_ (policy_name, ::xml_schema::flags (), this),
    policy_description_ (policy_description, ::xml_schema::flags (), this),
    startup_config_ (startup_config, ::xml_schema::flags (), this),
    adapt_config_ (::xml_schema::flags (), this)
  {
  }

  PolicyConfigurationType::
  PolicyConfigurationType (const PolicyConfigurationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    policy_name_ (x.policy_name_, f, this),
    policy_description_ (x.policy_description_, f, this),
    startup_config_ (x.startup_config_, f, this),
    adapt_config_ (x.adapt_config_, f, this)
  {
  }

  PolicyConfigurationType::
  PolicyConfigurationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    policy_name_ (f, this),
    policy_description_ (f, this),
    startup_config_ (f, this),
    adapt_config_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PolicyConfigurationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // policy-name
      //
      if (n.name () == "policy-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< policy_name_type > r (
          policy_name_traits::create (i, f, this));

        if (!policy_name_.present ())
        {
          this->policy_name_.set (r);
          continue;
        }
      }

      // policy-description
      //
      if (n.name () == "policy-description" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< policy_description_type > r (
          policy_description_traits::create (i, f, this));

        if (!policy_description_.present ())
        {
          this->policy_description_.set (r);
          continue;
        }
      }

      // startup-config
      //
      if (n.name () == "startup-config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startup_config_type > r (
          startup_config_traits::create (i, f, this));

        if (!startup_config_.present ())
        {
          this->startup_config_.set (r);
          continue;
        }
      }

      // adapt-config
      //
      if (n.name () == "adapt-config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< adapt_config_type > r (
          adapt_config_traits::create (i, f, this));

        if (!this->adapt_config_)
        {
          this->adapt_config_.set (r);
          continue;
        }
      }

      break;
    }

    if (!policy_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "policy-name",
        "");
    }

    if (!policy_description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "policy-description",
        "");
    }

    if (!startup_config_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "startup-config",
        "");
    }
  }

  PolicyConfigurationType* PolicyConfigurationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PolicyConfigurationType (*this, f, c);
  }

  PolicyConfigurationType::
  ~PolicyConfigurationType ()
  {
  }

  // PolicyType
  //

  PolicyType::
  PolicyType (const comparisson_attibute_type& comparisson_attibute,
              const unit_type& unit)
  : ::xml_schema::type (),
    comparisson_attibute_ (comparisson_attibute, ::xml_schema::flags (), this),
    unit_ (unit, ::xml_schema::flags (), this),
    lower_ (::xml_schema::flags (), this),
    range_ (::xml_schema::flags (), this),
    greater_ (::xml_schema::flags (), this)
  {
  }

  PolicyType::
  PolicyType (const PolicyType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    comparisson_attibute_ (x.comparisson_attibute_, f, this),
    unit_ (x.unit_, f, this),
    lower_ (x.lower_, f, this),
    range_ (x.range_, f, this),
    greater_ (x.greater_, f, this)
  {
  }

  PolicyType::
  PolicyType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    comparisson_attibute_ (f, this),
    unit_ (f, this),
    lower_ (f, this),
    range_ (f, this),
    greater_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PolicyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // comparisson-attibute
      //
      if (n.name () == "comparisson-attibute" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< comparisson_attibute_type > r (
          comparisson_attibute_traits::create (i, f, this));

        if (!comparisson_attibute_.present ())
        {
          this->comparisson_attibute_.set (r);
          continue;
        }
      }

      // unit
      //
      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        if (!unit_.present ())
        {
          this->unit_.set (r);
          continue;
        }
      }

      // lower
      //
      if (n.name () == "lower" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lower_type > r (
          lower_traits::create (i, f, this));

        if (!this->lower_)
        {
          this->lower_.set (r);
          continue;
        }
      }

      // range
      //
      if (n.name () == "range" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< range_type > r (
          range_traits::create (i, f, this));

        this->range_.push_back (r);
        continue;
      }

      // greater
      //
      if (n.name () == "greater" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< greater_type > r (
          greater_traits::create (i, f, this));

        if (!this->greater_)
        {
          this->greater_.set (r);
          continue;
        }
      }

      break;
    }

    if (!comparisson_attibute_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "comparisson-attibute",
        "");
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "unit",
        "");
    }
  }

  PolicyType* PolicyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PolicyType (*this, f, c);
  }

  PolicyType::
  ~PolicyType ()
  {
  }

  // ComplexPropertyType
  //

  ComplexPropertyType::
  ComplexPropertyType (const key_type& key)
  : ::xml_schema::type (),
    sub_property_ (::xml_schema::flags (), this),
    key_ (key, ::xml_schema::flags (), this)
  {
  }

  ComplexPropertyType::
  ComplexPropertyType (const ComplexPropertyType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sub_property_ (x.sub_property_, f, this),
    key_ (x.key_, f, this)
  {
  }

  ComplexPropertyType::
  ComplexPropertyType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sub_property_ (f, this),
    key_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ComplexPropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sub-property
      //
      if (n.name () == "sub-property" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< sub_property_type > r (
          sub_property_traits::create (i, f, this));

        this->sub_property_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.set (r);
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }
  }

  ComplexPropertyType* ComplexPropertyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComplexPropertyType (*this, f, c);
  }

  ComplexPropertyType::
  ~ComplexPropertyType ()
  {
  }

  // SimplePropertyType
  //

  SimplePropertyType::
  SimplePropertyType (const key_type& key)
  : ::xml_schema::string (),
    key_ (key, ::xml_schema::flags (), this)
  {
  }

  SimplePropertyType::
  SimplePropertyType (const char* _xsd_string_base,
                      const key_type& key)
  : ::xml_schema::string (_xsd_string_base),
    key_ (key, ::xml_schema::flags (), this)
  {
  }

  SimplePropertyType::
  SimplePropertyType (const ::std::string& _xsd_string_base,
                      const key_type& key)
  : ::xml_schema::string (_xsd_string_base),
    key_ (key, ::xml_schema::flags (), this)
  {
  }

  SimplePropertyType::
  SimplePropertyType (const ::xml_schema::string& _xsd_string_base,
                      const key_type& key)
  : ::xml_schema::string (_xsd_string_base),
    key_ (key, ::xml_schema::flags (), this)
  {
  }

  SimplePropertyType::
  SimplePropertyType (const SimplePropertyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    key_ (x.key_, f, this)
  {
  }

  SimplePropertyType::
  SimplePropertyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    key_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void SimplePropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.set (r);
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }
  }

  SimplePropertyType* SimplePropertyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SimplePropertyType (*this, f, c);
  }

  SimplePropertyType::
  ~SimplePropertyType ()
  {
  }

  // IFType
  //

  IFType::
  IFType (const operations_type& operations)
  : ::xml_schema::type (),
    equals_ (::xml_schema::flags (), this),
    lower_ (::xml_schema::flags (), this),
    greater_ (::xml_schema::flags (), this),
    operations_ (operations, ::xml_schema::flags (), this)
  {
  }

  IFType::
  IFType (::std::auto_ptr< operations_type >& operations)
  : ::xml_schema::type (),
    equals_ (::xml_schema::flags (), this),
    lower_ (::xml_schema::flags (), this),
    greater_ (::xml_schema::flags (), this),
    operations_ (operations, ::xml_schema::flags (), this)
  {
  }

  IFType::
  IFType (const IFType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    equals_ (x.equals_, f, this),
    lower_ (x.lower_, f, this),
    greater_ (x.greater_, f, this),
    operations_ (x.operations_, f, this)
  {
  }

  IFType::
  IFType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    equals_ (f, this),
    lower_ (f, this),
    greater_ (f, this),
    operations_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void IFType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // equals
      //
      if (n.name () == "equals" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< equals_type > r (
          equals_traits::create (i, f, this));

        this->equals_.push_back (r);
        continue;
      }

      // lower
      //
      if (n.name () == "lower" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< lower_type > r (
          lower_traits::create (i, f, this));

        this->lower_.push_back (r);
        continue;
      }

      // greater
      //
      if (n.name () == "greater" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< greater_type > r (
          greater_traits::create (i, f, this));

        this->greater_.push_back (r);
        continue;
      }

      // operations
      //
      if (n.name () == "operations" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< operations_type > r (
          operations_traits::create (i, f, this));

        if (!operations_.present ())
        {
          this->operations_.set (r);
          continue;
        }
      }

      break;
    }

    if (!operations_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "operations",
        "");
    }
  }

  IFType* IFType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IFType (*this, f, c);
  }

  IFType::
  ~IFType ()
  {
  }

  // ProviderType
  //

  const ProviderType::update_time_type ProviderType::update_time_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::unsigned_int, char >::create (
      ::std::string ("1000"), 0, 0, 0));

  ProviderType::
  ProviderType (const default_value_type& default_value)
  : ::xml_schema::string (),
    default_value_ (default_value, ::xml_schema::flags (), this),
    update_time_ (update_time_default_value (), ::xml_schema::flags (), this)
  {
  }

  ProviderType::
  ProviderType (const char* _xsd_string_base,
                const default_value_type& default_value)
  : ::xml_schema::string (_xsd_string_base),
    default_value_ (default_value, ::xml_schema::flags (), this),
    update_time_ (update_time_default_value (), ::xml_schema::flags (), this)
  {
  }

  ProviderType::
  ProviderType (const ::std::string& _xsd_string_base,
                const default_value_type& default_value)
  : ::xml_schema::string (_xsd_string_base),
    default_value_ (default_value, ::xml_schema::flags (), this),
    update_time_ (update_time_default_value (), ::xml_schema::flags (), this)
  {
  }

  ProviderType::
  ProviderType (const ::xml_schema::string& _xsd_string_base,
                const default_value_type& default_value)
  : ::xml_schema::string (_xsd_string_base),
    default_value_ (default_value, ::xml_schema::flags (), this),
    update_time_ (update_time_default_value (), ::xml_schema::flags (), this)
  {
  }

  ProviderType::
  ProviderType (const ProviderType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_value_ (x.default_value_, f, this),
    update_time_ (x.update_time_, f, this)
  {
  }

  ProviderType::
  ProviderType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_value_ (f, this),
    update_time_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ProviderType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-value" && n.namespace_ ().empty ())
      {
        this->default_value_.set (default_value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "update-time" && n.namespace_ ().empty ())
      {
        this->update_time_.set (update_time_traits::create (i, f, this));
        continue;
      }
    }

    if (!default_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "default-value",
        "");
    }

    if (!update_time_.present ())
    {
      this->update_time_.set (update_time_default_value ());
    }
  }

  ProviderType* ProviderType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProviderType (*this, f, c);
  }

  ProviderType::
  ~ProviderType ()
  {
  }

  // startup_config
  //

  startup_config::
  startup_config (const negotiation_type& negotiation,
                  const transport_type& transport,
                  const stream_type& stream)
  : ::xml_schema::type (),
    negotiation_ (negotiation, ::xml_schema::flags (), this),
    transport_ (transport, ::xml_schema::flags (), this),
    stream_ (stream, ::xml_schema::flags (), this)
  {
  }

  startup_config::
  startup_config (const negotiation_type& negotiation,
                  ::std::auto_ptr< transport_type >& transport,
                  ::std::auto_ptr< stream_type >& stream)
  : ::xml_schema::type (),
    negotiation_ (negotiation, ::xml_schema::flags (), this),
    transport_ (transport, ::xml_schema::flags (), this),
    stream_ (stream, ::xml_schema::flags (), this)
  {
  }

  startup_config::
  startup_config (const startup_config& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    negotiation_ (x.negotiation_, f, this),
    transport_ (x.transport_, f, this),
    stream_ (x.stream_, f, this)
  {
  }

  startup_config::
  startup_config (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    negotiation_ (f, this),
    transport_ (f, this),
    stream_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void startup_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // negotiation
      //
      if (n.name () == "negotiation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< negotiation_type > r (
          negotiation_traits::create (i, f, this));

        if (!negotiation_.present ())
        {
          this->negotiation_.set (r);
          continue;
        }
      }

      // transport
      //
      if (n.name () == "transport" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< transport_type > r (
          transport_traits::create (i, f, this));

        if (!transport_.present ())
        {
          this->transport_.set (r);
          continue;
        }
      }

      // stream
      //
      if (n.name () == "stream" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stream_type > r (
          stream_traits::create (i, f, this));

        if (!stream_.present ())
        {
          this->stream_.set (r);
          continue;
        }
      }

      break;
    }

    if (!negotiation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "negotiation",
        "");
    }

    if (!transport_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "transport",
        "");
    }

    if (!stream_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stream",
        "");
    }
  }

  startup_config* startup_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class startup_config (*this, f, c);
  }

  startup_config::
  ~startup_config ()
  {
  }

  // adapt_config
  //

  adapt_config::
  adapt_config ()
  : ::xml_schema::type (),
    stream_ (::xml_schema::flags (), this),
    transport_ (::xml_schema::flags (), this)
  {
  }

  adapt_config::
  adapt_config (const adapt_config& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    stream_ (x.stream_, f, this),
    transport_ (x.transport_, f, this)
  {
  }

  adapt_config::
  adapt_config (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    stream_ (f, this),
    transport_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void adapt_config::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stream
      //
      if (n.name () == "stream" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< stream_type > r (
          stream_traits::create (i, f, this));

        if (!this->stream_)
        {
          this->stream_.set (r);
          continue;
        }
      }

      // transport
      //
      if (n.name () == "transport" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< transport_type > r (
          transport_traits::create (i, f, this));

        if (!this->transport_)
        {
          this->transport_.set (r);
          continue;
        }
      }

      break;
    }
  }

  adapt_config* adapt_config::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class adapt_config (*this, f, c);
  }

  adapt_config::
  ~adapt_config ()
  {
  }

  // comparisson_attibute
  //

  comparisson_attibute::
  comparisson_attibute ()
  : ::xml_schema::string ()
  {
  }

  comparisson_attibute::
  comparisson_attibute (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const comparisson_attibute& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  comparisson_attibute::
  comparisson_attibute (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  comparisson_attibute* comparisson_attibute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comparisson_attibute (*this, f, c);
  }

  comparisson_attibute::
  ~comparisson_attibute ()
  {
  }

  // unit
  //

  unit::
  unit ()
  : ::xml_schema::string ()
  {
  }

  unit::
  unit (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  unit::
  unit (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  unit::
  unit (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  unit::
  unit (const unit& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  unit::
  unit (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  unit::
  unit (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  unit::
  unit (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  unit* unit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unit (*this, f, c);
  }

  unit::
  ~unit ()
  {
  }

  // lower
  //

  lower::
  lower (const threshold_type& threshold)
  : ::xml_schema::type (),
    complexproperty_ (::xml_schema::flags (), this),
    simpleproperty_ (::xml_schema::flags (), this),
    if__ (::xml_schema::flags (), this),
    threshold_ (threshold, ::xml_schema::flags (), this)
  {
  }

  lower::
  lower (const lower& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    complexproperty_ (x.complexproperty_, f, this),
    simpleproperty_ (x.simpleproperty_, f, this),
    if__ (x.if__, f, this),
    threshold_ (x.threshold_, f, this)
  {
  }

  lower::
  lower (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    complexproperty_ (f, this),
    simpleproperty_ (f, this),
    if__ (f, this),
    threshold_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void lower::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< if_type > r (
          if_traits::create (i, f, this));

        this->if__.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "threshold" && n.namespace_ ().empty ())
      {
        this->threshold_.set (threshold_traits::create (i, f, this));
        continue;
      }
    }

    if (!threshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "threshold",
        "");
    }
  }

  lower* lower::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lower (*this, f, c);
  }

  lower::
  ~lower ()
  {
  }

  // range
  //

  range::
  range (const from_type& from,
         const to_type& to)
  : ::xml_schema::type (),
    complexproperty_ (::xml_schema::flags (), this),
    simpleproperty_ (::xml_schema::flags (), this),
    if__ (::xml_schema::flags (), this),
    from_ (from, ::xml_schema::flags (), this),
    to_ (to, ::xml_schema::flags (), this)
  {
  }

  range::
  range (const range& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    complexproperty_ (x.complexproperty_, f, this),
    simpleproperty_ (x.simpleproperty_, f, this),
    if__ (x.if__, f, this),
    from_ (x.from_, f, this),
    to_ (x.to_, f, this)
  {
  }

  range::
  range (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    complexproperty_ (f, this),
    simpleproperty_ (f, this),
    if__ (f, this),
    from_ (f, this),
    to_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void range::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< if_type > r (
          if_traits::create (i, f, this));

        this->if__.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "from" && n.namespace_ ().empty ())
      {
        this->from_.set (from_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "to" && n.namespace_ ().empty ())
      {
        this->to_.set (to_traits::create (i, f, this));
        continue;
      }
    }

    if (!from_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "from",
        "");
    }

    if (!to_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "to",
        "");
    }
  }

  range* range::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class range (*this, f, c);
  }

  range::
  ~range ()
  {
  }

  // greater
  //

  greater::
  greater (const threshold_type& threshold)
  : ::xml_schema::type (),
    complexproperty_ (::xml_schema::flags (), this),
    simpleproperty_ (::xml_schema::flags (), this),
    if__ (::xml_schema::flags (), this),
    threshold_ (threshold, ::xml_schema::flags (), this)
  {
  }

  greater::
  greater (const greater& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    complexproperty_ (x.complexproperty_, f, this),
    simpleproperty_ (x.simpleproperty_, f, this),
    if__ (x.if__, f, this),
    threshold_ (x.threshold_, f, this)
  {
  }

  greater::
  greater (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    complexproperty_ (f, this),
    simpleproperty_ (f, this),
    if__ (f, this),
    threshold_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void greater::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< if_type > r (
          if_traits::create (i, f, this));

        this->if__.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "threshold" && n.namespace_ ().empty ())
      {
        this->threshold_.set (threshold_traits::create (i, f, this));
        continue;
      }
    }

    if (!threshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "threshold",
        "");
    }
  }

  greater* greater::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class greater (*this, f, c);
  }

  greater::
  ~greater ()
  {
  }

  // key
  //

  key::
  key ()
  : ::xml_schema::string ()
  {
  }

  key::
  key (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key::
  key (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key::
  key (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key::
  key (const key& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  key::
  key (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  key::
  key (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  key::
  key (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  key* key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key (*this, f, c);
  }

  key::
  ~key ()
  {
  }

  // key1
  //

  key1::
  key1 ()
  : ::xml_schema::string ()
  {
  }

  key1::
  key1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key1::
  key1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key1::
  key1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  key1::
  key1 (const key1& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  key1::
  key1 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  key1::
  key1 (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  key1::
  key1 (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  key1* key1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key1 (*this, f, c);
  }

  key1::
  ~key1 ()
  {
  }

  // equals
  //

  equals::
  equals (const Lhs_type& Lhs,
          const Rhs_type& Rhs)
  : ::xml_schema::type (),
    Lhs_ (Lhs, ::xml_schema::flags (), this),
    Rhs_ (Rhs, ::xml_schema::flags (), this)
  {
  }

  equals::
  equals (const equals& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Lhs_ (x.Lhs_, f, this),
    Rhs_ (x.Rhs_, f, this)
  {
  }

  equals::
  equals (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Lhs_ (f, this),
    Rhs_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void equals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lhs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Lhs_type > r (
          Lhs_traits::create (i, f, this));

        this->Lhs_.set (r);
        continue;
      }

      if (n.name () == "Rhs" && n.namespace_ ().empty ())
      {
        this->Rhs_.set (Rhs_traits::create (i, f, this));
        continue;
      }
    }

    if (!Lhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Lhs",
        "");
    }

    if (!Rhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Rhs",
        "");
    }
  }

  equals* equals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class equals (*this, f, c);
  }

  equals::
  ~equals ()
  {
  }

  // lower1
  //

  const lower1::equals_type lower1::equals_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("false"), 0, 0, 0));

  lower1::
  lower1 (const Lhs_type& Lhs,
          const Rhs_type& Rhs)
  : ::xml_schema::type (),
    Lhs_ (Lhs, ::xml_schema::flags (), this),
    Rhs_ (Rhs, ::xml_schema::flags (), this),
    equals_ (equals_default_value (), ::xml_schema::flags (), this)
  {
  }

  lower1::
  lower1 (const lower1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Lhs_ (x.Lhs_, f, this),
    Rhs_ (x.Rhs_, f, this),
    equals_ (x.equals_, f, this)
  {
  }

  lower1::
  lower1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Lhs_ (f, this),
    Rhs_ (f, this),
    equals_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void lower1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lhs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Lhs_type > r (
          Lhs_traits::create (i, f, this));

        this->Lhs_.set (r);
        continue;
      }

      if (n.name () == "Rhs" && n.namespace_ ().empty ())
      {
        this->Rhs_.set (Rhs_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "equals" && n.namespace_ ().empty ())
      {
        this->equals_.set (equals_traits::create (i, f, this));
        continue;
      }
    }

    if (!Lhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Lhs",
        "");
    }

    if (!Rhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Rhs",
        "");
    }

    if (!equals_.present ())
    {
      this->equals_.set (equals_default_value ());
    }
  }

  lower1* lower1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lower1 (*this, f, c);
  }

  lower1::
  ~lower1 ()
  {
  }

  // greater1
  //

  const greater1::equals_type greater1::equals_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("false"), 0, 0, 0));

  greater1::
  greater1 (const Lhs_type& Lhs,
            const Rhs_type& Rhs)
  : ::xml_schema::type (),
    Lhs_ (Lhs, ::xml_schema::flags (), this),
    Rhs_ (Rhs, ::xml_schema::flags (), this),
    equals_ (equals_default_value (), ::xml_schema::flags (), this)
  {
  }

  greater1::
  greater1 (const greater1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Lhs_ (x.Lhs_, f, this),
    Rhs_ (x.Rhs_, f, this),
    equals_ (x.equals_, f, this)
  {
  }

  greater1::
  greater1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Lhs_ (f, this),
    Rhs_ (f, this),
    equals_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void greater1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lhs" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Lhs_type > r (
          Lhs_traits::create (i, f, this));

        this->Lhs_.set (r);
        continue;
      }

      if (n.name () == "Rhs" && n.namespace_ ().empty ())
      {
        this->Rhs_.set (Rhs_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "equals" && n.namespace_ ().empty ())
      {
        this->equals_.set (equals_traits::create (i, f, this));
        continue;
      }
    }

    if (!Lhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Lhs",
        "");
    }

    if (!Rhs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Rhs",
        "");
    }

    if (!equals_.present ())
    {
      this->equals_.set (equals_default_value ());
    }
  }

  greater1* greater1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class greater1 (*this, f, c);
  }

  greater1::
  ~greater1 ()
  {
  }

  // operations
  //

  operations::
  operations ()
  : ::xml_schema::type (),
    simpleproperty_ (::xml_schema::flags (), this),
    complexproperty_ (::xml_schema::flags (), this)
  {
  }

  operations::
  operations (const operations& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    simpleproperty_ (x.simpleproperty_, f, this),
    complexproperty_ (x.complexproperty_, f, this)
  {
  }

  operations::
  operations (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    simpleproperty_ (f, this),
    complexproperty_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void operations::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      break;
    }
  }

  operations* operations::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class operations (*this, f, c);
  }

  operations::
  ~operations ()
  {
  }

  // negotiation
  //

  negotiation::
  negotiation ()
  : ::xml_schema::string ()
  {
  }

  negotiation::
  negotiation (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  negotiation::
  negotiation (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  negotiation::
  negotiation (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  negotiation::
  negotiation (const negotiation& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  negotiation::
  negotiation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  negotiation::
  negotiation (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  negotiation::
  negotiation (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  negotiation* negotiation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class negotiation (*this, f, c);
  }

  negotiation::
  ~negotiation ()
  {
  }

  // transport
  //

  const transport::enable_adaptation_type transport::enable_adaptation_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("true"), 0, 0, 0));

  transport::
  transport (const protocol_type& protocol,
             const plugin_name_type& plugin_name,
             const library_name_type& library_name,
             const enable_adaptation_type& enable_adaptation)
  : ::xml_schema::type (),
    protocol_ (protocol, ::xml_schema::flags (), this),
    plugin_name_ (plugin_name, ::xml_schema::flags (), this),
    library_name_ (library_name, ::xml_schema::flags (), this),
    library_directory_ (::xml_schema::flags (), this),
    enable_adaptation_ (enable_adaptation, ::xml_schema::flags (), this),
    provides_ (::xml_schema::flags (), this),
    complexproperty_ (::xml_schema::flags (), this),
    simpleproperty_ (::xml_schema::flags (), this)
  {
  }

  transport::
  transport (const transport& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    protocol_ (x.protocol_, f, this),
    plugin_name_ (x.plugin_name_, f, this),
    library_name_ (x.library_name_, f, this),
    library_directory_ (x.library_directory_, f, this),
    enable_adaptation_ (x.enable_adaptation_, f, this),
    provides_ (x.provides_, f, this),
    complexproperty_ (x.complexproperty_, f, this),
    simpleproperty_ (x.simpleproperty_, f, this)
  {
  }

  transport::
  transport (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    protocol_ (f, this),
    plugin_name_ (f, this),
    library_name_ (f, this),
    library_directory_ (f, this),
    enable_adaptation_ (f, this),
    provides_ (f, this),
    complexproperty_ (f, this),
    simpleproperty_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void transport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // protocol
      //
      if (n.name () == "protocol" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< protocol_type > r (
          protocol_traits::create (i, f, this));

        if (!protocol_.present ())
        {
          this->protocol_.set (r);
          continue;
        }
      }

      // plugin-name
      //
      if (n.name () == "plugin-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< plugin_name_type > r (
          plugin_name_traits::create (i, f, this));

        if (!plugin_name_.present ())
        {
          this->plugin_name_.set (r);
          continue;
        }
      }

      // library-name
      //
      if (n.name () == "library-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< library_name_type > r (
          library_name_traits::create (i, f, this));

        if (!library_name_.present ())
        {
          this->library_name_.set (r);
          continue;
        }
      }

      // library-directory
      //
      if (n.name () == "library-directory" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< library_directory_type > r (
          library_directory_traits::create (i, f, this));

        if (!this->library_directory_)
        {
          this->library_directory_.set (r);
          continue;
        }
      }

      // enable-adaptation
      //
      if (n.name () == "enable-adaptation" && n.namespace_ ().empty ())
      {
        if (!enable_adaptation_.present ())
        {
          this->enable_adaptation_.set (enable_adaptation_traits::create (i, f, this));
          continue;
        }
      }

      // provides
      //
      if (n.name () == "provides" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< provides_type > r (
          provides_traits::create (i, f, this));

        if (!this->provides_)
        {
          this->provides_.set (r);
          continue;
        }
      }

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      break;
    }

    if (!protocol_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "protocol",
        "");
    }

    if (!plugin_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "plugin-name",
        "");
    }

    if (!library_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "library-name",
        "");
    }

    if (!enable_adaptation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "enable-adaptation",
        "");
    }
  }

  transport* transport::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class transport (*this, f, c);
  }

  transport::
  ~transport ()
  {
  }

  // stream
  //

  const stream::enable_adaptation_type stream::enable_adaptation_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("true"), 0, 0, 0));

  stream::
  stream (const plugin_name_type& plugin_name,
          const library_name_type& library_name,
          const enable_adaptation_type& enable_adaptation)
  : ::xml_schema::type (),
    plugin_name_ (plugin_name, ::xml_schema::flags (), this),
    library_name_ (library_name, ::xml_schema::flags (), this),
    library_directory_ (::xml_schema::flags (), this),
    video_transmission_ (::xml_schema::flags (), this),
    audio_transmission_ (::xml_schema::flags (), this),
    enable_adaptation_ (enable_adaptation, ::xml_schema::flags (), this),
    provides_ (::xml_schema::flags (), this),
    complexproperty_ (::xml_schema::flags (), this),
    simpleproperty_ (::xml_schema::flags (), this)
  {
  }

  stream::
  stream (const stream& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    plugin_name_ (x.plugin_name_, f, this),
    library_name_ (x.library_name_, f, this),
    library_directory_ (x.library_directory_, f, this),
    video_transmission_ (x.video_transmission_, f, this),
    audio_transmission_ (x.audio_transmission_, f, this),
    enable_adaptation_ (x.enable_adaptation_, f, this),
    provides_ (x.provides_, f, this),
    complexproperty_ (x.complexproperty_, f, this),
    simpleproperty_ (x.simpleproperty_, f, this)
  {
  }

  stream::
  stream (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    plugin_name_ (f, this),
    library_name_ (f, this),
    library_directory_ (f, this),
    video_transmission_ (f, this),
    audio_transmission_ (f, this),
    enable_adaptation_ (f, this),
    provides_ (f, this),
    complexproperty_ (f, this),
    simpleproperty_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void stream::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // plugin-name
      //
      if (n.name () == "plugin-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< plugin_name_type > r (
          plugin_name_traits::create (i, f, this));

        if (!plugin_name_.present ())
        {
          this->plugin_name_.set (r);
          continue;
        }
      }

      // library-name
      //
      if (n.name () == "library-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< library_name_type > r (
          library_name_traits::create (i, f, this));

        if (!library_name_.present ())
        {
          this->library_name_.set (r);
          continue;
        }
      }

      // library-directory
      //
      if (n.name () == "library-directory" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< library_directory_type > r (
          library_directory_traits::create (i, f, this));

        if (!this->library_directory_)
        {
          this->library_directory_.set (r);
          continue;
        }
      }

      // video-transmission
      //
      if (n.name () == "video-transmission" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< video_transmission_type > r (
          video_transmission_traits::create (i, f, this));

        if (!this->video_transmission_)
        {
          this->video_transmission_.set (r);
          continue;
        }
      }

      // audio-transmission
      //
      if (n.name () == "audio-transmission" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< audio_transmission_type > r (
          audio_transmission_traits::create (i, f, this));

        if (!this->audio_transmission_)
        {
          this->audio_transmission_.set (r);
          continue;
        }
      }

      // enable-adaptation
      //
      if (n.name () == "enable-adaptation" && n.namespace_ ().empty ())
      {
        if (!enable_adaptation_.present ())
        {
          this->enable_adaptation_.set (enable_adaptation_traits::create (i, f, this));
          continue;
        }
      }

      // provides
      //
      if (n.name () == "provides" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< provides_type > r (
          provides_traits::create (i, f, this));

        if (!this->provides_)
        {
          this->provides_.set (r);
          continue;
        }
      }

      // complexproperty
      //
      if (n.name () == "complexproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< complexproperty_type > r (
          complexproperty_traits::create (i, f, this));

        this->complexproperty_.push_back (r);
        continue;
      }

      // simpleproperty
      //
      if (n.name () == "simpleproperty" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< simpleproperty_type > r (
          simpleproperty_traits::create (i, f, this));

        this->simpleproperty_.push_back (r);
        continue;
      }

      break;
    }

    if (!plugin_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "plugin-name",
        "");
    }

    if (!library_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "library-name",
        "");
    }

    if (!enable_adaptation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "enable-adaptation",
        "");
    }
  }

  stream* stream::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stream (*this, f, c);
  }

  stream::
  ~stream ()
  {
  }

  // stream1
  //

  stream1::
  stream1 (const adaptation_method_type& adaptation_method)
  : ::xml_schema::type (),
    adaptation_method_ (adaptation_method, ::xml_schema::flags (), this),
    policy_ (::xml_schema::flags (), this)
  {
  }

  stream1::
  stream1 (const stream1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    adaptation_method_ (x.adaptation_method_, f, this),
    policy_ (x.policy_, f, this)
  {
  }

  stream1::
  stream1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    adaptation_method_ (f, this),
    policy_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void stream1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // adaptation-method
      //
      if (n.name () == "adaptation-method" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< adaptation_method_type > r (
          adaptation_method_traits::create (i, f, this));

        if (!adaptation_method_.present ())
        {
          this->adaptation_method_.set (r);
          continue;
        }
      }

      // policy
      //
      if (n.name () == "policy" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< policy_type > r (
          policy_traits::create (i, f, this));

        this->policy_.push_back (r);
        continue;
      }

      break;
    }

    if (!adaptation_method_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "adaptation-method",
        "");
    }
  }

  stream1* stream1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stream1 (*this, f, c);
  }

  stream1::
  ~stream1 ()
  {
  }

  // transport1
  //

  transport1::
  transport1 (const adaptation_method_type& adaptation_method)
  : ::xml_schema::type (),
    adaptation_method_ (adaptation_method, ::xml_schema::flags (), this),
    policy_ (::xml_schema::flags (), this)
  {
  }

  transport1::
  transport1 (const transport1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    adaptation_method_ (x.adaptation_method_, f, this),
    policy_ (x.policy_, f, this)
  {
  }

  transport1::
  transport1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    adaptation_method_ (f, this),
    policy_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void transport1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // adaptation-method
      //
      if (n.name () == "adaptation-method" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< adaptation_method_type > r (
          adaptation_method_traits::create (i, f, this));

        if (!adaptation_method_.present ())
        {
          this->adaptation_method_.set (r);
          continue;
        }
      }

      // policy
      //
      if (n.name () == "policy" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< policy_type > r (
          policy_traits::create (i, f, this));

        this->policy_.push_back (r);
        continue;
      }

      break;
    }

    if (!adaptation_method_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "adaptation-method",
        "");
    }
  }

  transport1* transport1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class transport1 (*this, f, c);
  }

  transport1::
  ~transport1 ()
  {
  }

  // protocol
  //

  protocol::
  protocol ()
  : ::xml_schema::string ()
  {
  }

  protocol::
  protocol (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  protocol::
  protocol (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  protocol::
  protocol (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  protocol::
  protocol (const protocol& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  protocol::
  protocol (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  protocol::
  protocol (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  protocol::
  protocol (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  protocol* protocol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class protocol (*this, f, c);
  }

  protocol::
  ~protocol ()
  {
  }

  // plugin_name
  //

  plugin_name::
  plugin_name ()
  : ::xml_schema::string ()
  {
  }

  plugin_name::
  plugin_name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name::
  plugin_name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name::
  plugin_name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name::
  plugin_name (const plugin_name& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  plugin_name::
  plugin_name (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  plugin_name::
  plugin_name (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  plugin_name::
  plugin_name (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  plugin_name* plugin_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class plugin_name (*this, f, c);
  }

  plugin_name::
  ~plugin_name ()
  {
  }

  // library_name
  //

  library_name::
  library_name ()
  : ::xml_schema::string ()
  {
  }

  library_name::
  library_name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name::
  library_name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name::
  library_name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name::
  library_name (const library_name& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  library_name::
  library_name (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  library_name::
  library_name (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  library_name::
  library_name (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  library_name* library_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class library_name (*this, f, c);
  }

  library_name::
  ~library_name ()
  {
  }

  // library_directory
  //

  library_directory::
  library_directory ()
  : ::xml_schema::string ()
  {
  }

  library_directory::
  library_directory (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory::
  library_directory (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory::
  library_directory (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory::
  library_directory (const library_directory& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  library_directory::
  library_directory (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  library_directory::
  library_directory (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  library_directory::
  library_directory (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  library_directory* library_directory::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class library_directory (*this, f, c);
  }

  library_directory::
  ~library_directory ()
  {
  }

  // provides
  //

  provides::
  provides ()
  : ::xml_schema::type (),
    provide_ (::xml_schema::flags (), this)
  {
  }

  provides::
  provides (const provides& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    provide_ (x.provide_, f, this)
  {
  }

  provides::
  provides (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    provide_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void provides::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // provide
      //
      if (n.name () == "provide" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< provide_type > r (
          provide_traits::create (i, f, this));

        this->provide_.push_back (r);
        continue;
      }

      break;
    }
  }

  provides* provides::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class provides (*this, f, c);
  }

  provides::
  ~provides ()
  {
  }

  // plugin_name1
  //

  plugin_name1::
  plugin_name1 ()
  : ::xml_schema::string ()
  {
  }

  plugin_name1::
  plugin_name1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name1::
  plugin_name1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name1::
  plugin_name1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  plugin_name1::
  plugin_name1 (const plugin_name1& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  plugin_name1::
  plugin_name1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  plugin_name1::
  plugin_name1 (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  plugin_name1::
  plugin_name1 (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  plugin_name1* plugin_name1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class plugin_name1 (*this, f, c);
  }

  plugin_name1::
  ~plugin_name1 ()
  {
  }

  // library_name1
  //

  library_name1::
  library_name1 ()
  : ::xml_schema::string ()
  {
  }

  library_name1::
  library_name1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name1::
  library_name1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name1::
  library_name1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_name1::
  library_name1 (const library_name1& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  library_name1::
  library_name1 (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  library_name1::
  library_name1 (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  library_name1::
  library_name1 (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  library_name1* library_name1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class library_name1 (*this, f, c);
  }

  library_name1::
  ~library_name1 ()
  {
  }

  // library_directory1
  //

  library_directory1::
  library_directory1 ()
  : ::xml_schema::string ()
  {
  }

  library_directory1::
  library_directory1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory1::
  library_directory1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory1::
  library_directory1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  library_directory1::
  library_directory1 (const library_directory1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  library_directory1::
  library_directory1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  library_directory1::
  library_directory1 (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  library_directory1::
  library_directory1 (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  library_directory1* library_directory1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class library_directory1 (*this, f, c);
  }

  library_directory1::
  ~library_directory1 ()
  {
  }

  // video_transmission
  //

  video_transmission::
  video_transmission (const video_codec_type& video_codec)
  : ::xml_schema::type (),
    video_codec_ (video_codec, ::xml_schema::flags (), this)
  {
  }

  video_transmission::
  video_transmission (const video_transmission& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    video_codec_ (x.video_codec_, f, this)
  {
  }

  video_transmission::
  video_transmission (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    video_codec_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void video_transmission::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // video-codec
      //
      if (n.name () == "video-codec" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< video_codec_type > r (
          video_codec_traits::create (i, f, this));

        if (!video_codec_.present ())
        {
          this->video_codec_.set (r);
          continue;
        }
      }

      break;
    }

    if (!video_codec_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "video-codec",
        "");
    }
  }

  video_transmission* video_transmission::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class video_transmission (*this, f, c);
  }

  video_transmission::
  ~video_transmission ()
  {
  }

  // audio_transmission
  //

  const audio_transmission::enablePreprocessing_type audio_transmission::enablePreprocessing_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("false"), 0, 0, 0));

  const audio_transmission::enableEchoCancellation_type audio_transmission::enableEchoCancellation_default_value_ (
    ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
      ::std::string ("false"), 0, 0, 0));

  audio_transmission::
  audio_transmission (const codec_name_type& codec_name)
  : ::xml_schema::type (),
    codec_name_ (codec_name, ::xml_schema::flags (), this),
    enablePreprocessing_ (enablePreprocessing_default_value (), ::xml_schema::flags (), this),
    enableEchoCancellation_ (enableEchoCancellation_default_value (), ::xml_schema::flags (), this)
  {
  }

  audio_transmission::
  audio_transmission (const audio_transmission& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    codec_name_ (x.codec_name_, f, this),
    enablePreprocessing_ (x.enablePreprocessing_, f, this),
    enableEchoCancellation_ (x.enableEchoCancellation_, f, this)
  {
  }

  audio_transmission::
  audio_transmission (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    codec_name_ (f, this),
    enablePreprocessing_ (f, this),
    enableEchoCancellation_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void audio_transmission::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // codec-name
      //
      if (n.name () == "codec-name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< codec_name_type > r (
          codec_name_traits::create (i, f, this));

        if (!codec_name_.present ())
        {
          this->codec_name_.set (r);
          continue;
        }
      }

      break;
    }

    if (!codec_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "codec-name",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "enablePreprocessing" && n.namespace_ ().empty ())
      {
        this->enablePreprocessing_.set (enablePreprocessing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enableEchoCancellation" && n.namespace_ ().empty ())
      {
        this->enableEchoCancellation_.set (enableEchoCancellation_traits::create (i, f, this));
        continue;
      }
    }

    if (!enablePreprocessing_.present ())
    {
      this->enablePreprocessing_.set (enablePreprocessing_default_value ());
    }

    if (!enableEchoCancellation_.present ())
    {
      this->enableEchoCancellation_.set (enableEchoCancellation_default_value ());
    }
  }

  audio_transmission* audio_transmission::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class audio_transmission (*this, f, c);
  }

  audio_transmission::
  ~audio_transmission ()
  {
  }

  // provides1
  //

  provides1::
  provides1 ()
  : ::xml_schema::type (),
    provide_ (::xml_schema::flags (), this)
  {
  }

  provides1::
  provides1 (const provides1& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    provide_ (x.provide_, f, this)
  {
  }

  provides1::
  provides1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    provide_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void provides1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // provide
      //
      if (n.name () == "provide" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< provide_type > r (
          provide_traits::create (i, f, this));

        this->provide_.push_back (r);
        continue;
      }

      break;
    }
  }

  provides1* provides1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class provides1 (*this, f, c);
  }

  provides1::
  ~provides1 ()
  {
  }

  // adaptation_method
  //

  adaptation_method::
  adaptation_method ()
  : ::xml_schema::string ()
  {
  }

  adaptation_method::
  adaptation_method (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method::
  adaptation_method (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method::
  adaptation_method (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method::
  adaptation_method (const adaptation_method& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  adaptation_method::
  adaptation_method (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  adaptation_method::
  adaptation_method (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  adaptation_method::
  adaptation_method (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  adaptation_method* adaptation_method::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class adaptation_method (*this, f, c);
  }

  adaptation_method::
  ~adaptation_method ()
  {
  }

  // adaptation_method1
  //

  adaptation_method1::
  adaptation_method1 ()
  : ::xml_schema::string ()
  {
  }

  adaptation_method1::
  adaptation_method1 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method1::
  adaptation_method1 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method1::
  adaptation_method1 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  adaptation_method1::
  adaptation_method1 (const adaptation_method1& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  adaptation_method1::
  adaptation_method1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  adaptation_method1::
  adaptation_method1 (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  adaptation_method1::
  adaptation_method1 (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  adaptation_method1* adaptation_method1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class adaptation_method1 (*this, f, c);
  }

  adaptation_method1::
  ~adaptation_method1 ()
  {
  }

  // codec_name
  //

  codec_name::
  codec_name ()
  : ::xml_schema::string ()
  {
  }

  codec_name::
  codec_name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  codec_name::
  codec_name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  codec_name::
  codec_name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  codec_name::
  codec_name (const codec_name& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  codec_name::
  codec_name (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  codec_name::
  codec_name (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  codec_name::
  codec_name (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  codec_name* codec_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class codec_name (*this, f, c);
  }

  codec_name::
  ~codec_name ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace AdaptationPolicy
{
  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::AdaptationPolicy::adaptation_policy (isrc, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::AdaptationPolicy::adaptation_policy (isrc, h, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::AdaptationPolicy::adaptation_policy (isrc, h, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::AdaptationPolicy::adaptation_policy (isrc, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::AdaptationPolicy::adaptation_policy (isrc, h, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::AdaptationPolicy::adaptation_policy (isrc, h, f, p);
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
      ::AdaptationPolicy::adaptation_policy (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
        ::AdaptationPolicy::adaptation_policy (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "adaptation-policy" &&
        n.namespace_ () == "AdaptationPolicy")
    {
      ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
        ::xsd::cxx::tree::traits< ::AdaptationPolicy::PolicyConfigurationType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "adaptation-policy",
      "AdaptationPolicy");
  }

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "adaptation-policy" &&
        n.namespace_ () == "AdaptationPolicy")
    {
      ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType > r (
        ::xsd::cxx::tree::traits< ::AdaptationPolicy::PolicyConfigurationType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "adaptation-policy",
      "AdaptationPolicy");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

