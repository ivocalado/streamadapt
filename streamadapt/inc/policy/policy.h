// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef POLICY_HXX
#define POLICY_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace AdaptationPolicy
{
  class PolicyConfigurationType;
  class PolicyType;
  class ComplexPropertyType;
  class SimplePropertyType;
  class IFType;
  class ProviderType;
  class startup_config;
  class adapt_config;
  class comparisson_attibute;
  class unit;
  class lower;
  class range;
  class greater;
  class key;
  class key1;
  class equals;
  class lower1;
  class greater1;
  class operations;
  class negotiation;
  class transport;
  class stream;
  class stream1;
  class transport1;
  class protocol;
  class plugin_name;
  class library_name;
  class library_directory;
  class provides;
  class plugin_name1;
  class library_name1;
  class library_directory1;
  class transmission_properties;
  class provides1;
  class adaptation_method;
  class adaptation_method1;
  class video_transmission;
  class audio_transmission;
  class transmission_type;
  class codec_name;
}


#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace AdaptationPolicy
{
  class PolicyConfigurationType: public ::xml_schema::type
  {
    public:
    // policy-name
    // 
    typedef ::xml_schema::string policy_name_type;
    typedef ::xsd::cxx::tree::traits< policy_name_type, char > policy_name_traits;

    const policy_name_type&
    policy_name () const;

    policy_name_type&
    policy_name ();

    void
    policy_name (const policy_name_type& x);

    void
    policy_name (::std::auto_ptr< policy_name_type > p);

    // policy-description
    // 
    typedef ::xml_schema::string policy_description_type;
    typedef ::xsd::cxx::tree::traits< policy_description_type, char > policy_description_traits;

    const policy_description_type&
    policy_description () const;

    policy_description_type&
    policy_description ();

    void
    policy_description (const policy_description_type& x);

    void
    policy_description (::std::auto_ptr< policy_description_type > p);

    // startup-config
    // 
    typedef ::AdaptationPolicy::startup_config startup_config_type;
    typedef ::xsd::cxx::tree::traits< startup_config_type, char > startup_config_traits;

    const startup_config_type&
    startup_config () const;

    startup_config_type&
    startup_config ();

    void
    startup_config (const startup_config_type& x);

    void
    startup_config (::std::auto_ptr< startup_config_type > p);

    // adapt-config
    // 
    typedef ::AdaptationPolicy::adapt_config adapt_config_type;
    typedef ::xsd::cxx::tree::optional< adapt_config_type > adapt_config_optional;
    typedef ::xsd::cxx::tree::traits< adapt_config_type, char > adapt_config_traits;

    const adapt_config_optional&
    adapt_config () const;

    adapt_config_optional&
    adapt_config ();

    void
    adapt_config (const adapt_config_type& x);

    void
    adapt_config (const adapt_config_optional& x);

    void
    adapt_config (::std::auto_ptr< adapt_config_type > p);

    // Constructors.
    //
    PolicyConfigurationType (const policy_name_type&,
                             const policy_description_type&,
                             const startup_config_type&);

    PolicyConfigurationType (const policy_name_type&,
                             const policy_description_type&,
                             ::std::auto_ptr< startup_config_type >&);

    PolicyConfigurationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    PolicyConfigurationType (const PolicyConfigurationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual PolicyConfigurationType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PolicyConfigurationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< policy_name_type > policy_name_;
    ::xsd::cxx::tree::one< policy_description_type > policy_description_;
    ::xsd::cxx::tree::one< startup_config_type > startup_config_;
    adapt_config_optional adapt_config_;
  };

  class PolicyType: public ::xml_schema::type
  {
    public:
    // comparisson-attibute
    // 
    typedef ::AdaptationPolicy::comparisson_attibute comparisson_attibute_type;
    typedef ::xsd::cxx::tree::traits< comparisson_attibute_type, char > comparisson_attibute_traits;

    const comparisson_attibute_type&
    comparisson_attibute () const;

    comparisson_attibute_type&
    comparisson_attibute ();

    void
    comparisson_attibute (const comparisson_attibute_type& x);

    void
    comparisson_attibute (::std::auto_ptr< comparisson_attibute_type > p);

    // unit
    // 
    typedef ::AdaptationPolicy::unit unit_type;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_type&
    unit () const;

    unit_type&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // lower
    // 
    typedef ::AdaptationPolicy::lower lower_type;
    typedef ::xsd::cxx::tree::optional< lower_type > lower_optional;
    typedef ::xsd::cxx::tree::traits< lower_type, char > lower_traits;

    const lower_optional&
    lower () const;

    lower_optional&
    lower ();

    void
    lower (const lower_type& x);

    void
    lower (const lower_optional& x);

    void
    lower (::std::auto_ptr< lower_type > p);

    // range
    // 
    typedef ::AdaptationPolicy::range range_type;
    typedef ::xsd::cxx::tree::sequence< range_type > range_sequence;
    typedef range_sequence::iterator range_iterator;
    typedef range_sequence::const_iterator range_const_iterator;
    typedef ::xsd::cxx::tree::traits< range_type, char > range_traits;

    const range_sequence&
    range () const;

    range_sequence&
    range ();

    void
    range (const range_sequence& s);

    // greater
    // 
    typedef ::AdaptationPolicy::greater greater_type;
    typedef ::xsd::cxx::tree::optional< greater_type > greater_optional;
    typedef ::xsd::cxx::tree::traits< greater_type, char > greater_traits;

    const greater_optional&
    greater () const;

    greater_optional&
    greater ();

    void
    greater (const greater_type& x);

    void
    greater (const greater_optional& x);

    void
    greater (::std::auto_ptr< greater_type > p);

    // Constructors.
    //
    PolicyType (const comparisson_attibute_type&,
                const unit_type&);

    PolicyType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    PolicyType (const PolicyType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual PolicyType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PolicyType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< comparisson_attibute_type > comparisson_attibute_;
    ::xsd::cxx::tree::one< unit_type > unit_;
    lower_optional lower_;
    range_sequence range_;
    greater_optional greater_;
  };

  class ComplexPropertyType: public ::xml_schema::type
  {
    public:
    // sub-property
    // 
    typedef ::AdaptationPolicy::SimplePropertyType sub_property_type;
    typedef ::xsd::cxx::tree::sequence< sub_property_type > sub_property_sequence;
    typedef sub_property_sequence::iterator sub_property_iterator;
    typedef sub_property_sequence::const_iterator sub_property_const_iterator;
    typedef ::xsd::cxx::tree::traits< sub_property_type, char > sub_property_traits;

    const sub_property_sequence&
    sub_property () const;

    sub_property_sequence&
    sub_property ();

    void
    sub_property (const sub_property_sequence& s);

    // key
    // 
    typedef ::AdaptationPolicy::key key_type;
    typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

    const key_type&
    key () const;

    key_type&
    key ();

    void
    key (const key_type& x);

    void
    key (::std::auto_ptr< key_type > p);

    // Constructors.
    //
    ComplexPropertyType (const key_type&);

    ComplexPropertyType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    ComplexPropertyType (const ComplexPropertyType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual ComplexPropertyType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ComplexPropertyType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    sub_property_sequence sub_property_;
    ::xsd::cxx::tree::one< key_type > key_;
  };

  class SimplePropertyType: public ::xml_schema::string
  {
    public:
    // key
    // 
    typedef ::AdaptationPolicy::key1 key_type;
    typedef ::xsd::cxx::tree::traits< key_type, char > key_traits;

    const key_type&
    key () const;

    key_type&
    key ();

    void
    key (const key_type& x);

    void
    key (::std::auto_ptr< key_type > p);

    // Constructors.
    //
    SimplePropertyType (const key_type&);

    SimplePropertyType (const char*,
                        const key_type&);

    SimplePropertyType (const ::std::string&,
                        const key_type&);

    SimplePropertyType (const ::xml_schema::string&,
                        const key_type&);

    SimplePropertyType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    SimplePropertyType (const SimplePropertyType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual SimplePropertyType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~SimplePropertyType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< key_type > key_;
  };

  class IFType: public ::xml_schema::type
  {
    public:
    // equals
    // 
    typedef ::AdaptationPolicy::equals equals_type;
    typedef ::xsd::cxx::tree::sequence< equals_type > equals_sequence;
    typedef equals_sequence::iterator equals_iterator;
    typedef equals_sequence::const_iterator equals_const_iterator;
    typedef ::xsd::cxx::tree::traits< equals_type, char > equals_traits;

    const equals_sequence&
    equals () const;

    equals_sequence&
    equals ();

    void
    equals (const equals_sequence& s);

    // lower
    // 
    typedef ::AdaptationPolicy::lower1 lower_type;
    typedef ::xsd::cxx::tree::sequence< lower_type > lower_sequence;
    typedef lower_sequence::iterator lower_iterator;
    typedef lower_sequence::const_iterator lower_const_iterator;
    typedef ::xsd::cxx::tree::traits< lower_type, char > lower_traits;

    const lower_sequence&
    lower () const;

    lower_sequence&
    lower ();

    void
    lower (const lower_sequence& s);

    // greater
    // 
    typedef ::AdaptationPolicy::greater1 greater_type;
    typedef ::xsd::cxx::tree::sequence< greater_type > greater_sequence;
    typedef greater_sequence::iterator greater_iterator;
    typedef greater_sequence::const_iterator greater_const_iterator;
    typedef ::xsd::cxx::tree::traits< greater_type, char > greater_traits;

    const greater_sequence&
    greater () const;

    greater_sequence&
    greater ();

    void
    greater (const greater_sequence& s);

    // operations
    // 
    typedef ::AdaptationPolicy::operations operations_type;
    typedef ::xsd::cxx::tree::traits< operations_type, char > operations_traits;

    const operations_type&
    operations () const;

    operations_type&
    operations ();

    void
    operations (const operations_type& x);

    void
    operations (::std::auto_ptr< operations_type > p);

    // Constructors.
    //
    IFType (const operations_type&);

    IFType (::std::auto_ptr< operations_type >&);

    IFType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    IFType (const IFType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual IFType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~IFType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    equals_sequence equals_;
    lower_sequence lower_;
    greater_sequence greater_;
    ::xsd::cxx::tree::one< operations_type > operations_;
  };

  class ProviderType: public ::xml_schema::string
  {
    public:
    // default-value
    // 
    typedef ::xml_schema::double_ default_value_type;
    typedef ::xsd::cxx::tree::traits< default_value_type, char, ::xsd::cxx::tree::schema_type::double_ > default_value_traits;

    const default_value_type&
    default_value () const;

    default_value_type&
    default_value ();

    void
    default_value (const default_value_type& x);

    // update-time
    // 
    typedef ::xml_schema::unsigned_int update_time_type;
    typedef ::xsd::cxx::tree::traits< update_time_type, char > update_time_traits;

    const update_time_type&
    update_time () const;

    update_time_type&
    update_time ();

    void
    update_time (const update_time_type& x);

    static const update_time_type&
    update_time_default_value ();

    // Constructors.
    //
    ProviderType (const default_value_type&);

    ProviderType (const char*,
                  const default_value_type&);

    ProviderType (const ::std::string&,
                  const default_value_type&);

    ProviderType (const ::xml_schema::string&,
                  const default_value_type&);

    ProviderType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    ProviderType (const ProviderType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual ProviderType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ProviderType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< default_value_type > default_value_;
    ::xsd::cxx::tree::one< update_time_type > update_time_;
    static const update_time_type update_time_default_value_;
  };

  class startup_config: public ::xml_schema::type
  {
    public:
    // negotiation
    // 
    typedef ::AdaptationPolicy::negotiation negotiation_type;
    typedef ::xsd::cxx::tree::traits< negotiation_type, char > negotiation_traits;

    const negotiation_type&
    negotiation () const;

    negotiation_type&
    negotiation ();

    void
    negotiation (const negotiation_type& x);

    void
    negotiation (::std::auto_ptr< negotiation_type > p);

    // transport
    // 
    typedef ::AdaptationPolicy::transport transport_type;
    typedef ::xsd::cxx::tree::traits< transport_type, char > transport_traits;

    const transport_type&
    transport () const;

    transport_type&
    transport ();

    void
    transport (const transport_type& x);

    void
    transport (::std::auto_ptr< transport_type > p);

    // stream
    // 
    typedef ::AdaptationPolicy::stream stream_type;
    typedef ::xsd::cxx::tree::traits< stream_type, char > stream_traits;

    const stream_type&
    stream () const;

    stream_type&
    stream ();

    void
    stream (const stream_type& x);

    void
    stream (::std::auto_ptr< stream_type > p);

    // Constructors.
    //
    startup_config (const negotiation_type&,
                    const transport_type&,
                    const stream_type&);

    startup_config (const negotiation_type&,
                    ::std::auto_ptr< transport_type >&,
                    ::std::auto_ptr< stream_type >&);

    startup_config (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    startup_config (const startup_config& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual startup_config*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~startup_config ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< negotiation_type > negotiation_;
    ::xsd::cxx::tree::one< transport_type > transport_;
    ::xsd::cxx::tree::one< stream_type > stream_;
  };

  class adapt_config: public ::xml_schema::type
  {
    public:
    // stream
    // 
    typedef ::AdaptationPolicy::stream1 stream_type;
    typedef ::xsd::cxx::tree::optional< stream_type > stream_optional;
    typedef ::xsd::cxx::tree::traits< stream_type, char > stream_traits;

    const stream_optional&
    stream () const;

    stream_optional&
    stream ();

    void
    stream (const stream_type& x);

    void
    stream (const stream_optional& x);

    void
    stream (::std::auto_ptr< stream_type > p);

    // transport
    // 
    typedef ::AdaptationPolicy::transport1 transport_type;
    typedef ::xsd::cxx::tree::optional< transport_type > transport_optional;
    typedef ::xsd::cxx::tree::traits< transport_type, char > transport_traits;

    const transport_optional&
    transport () const;

    transport_optional&
    transport ();

    void
    transport (const transport_type& x);

    void
    transport (const transport_optional& x);

    void
    transport (::std::auto_ptr< transport_type > p);

    // Constructors.
    //
    adapt_config ();

    adapt_config (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    adapt_config (const adapt_config& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual adapt_config*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~adapt_config ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    stream_optional stream_;
    transport_optional transport_;
  };

  class comparisson_attibute: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    comparisson_attibute ();

    comparisson_attibute (const char*);

    comparisson_attibute (const ::std::string&);

    comparisson_attibute (const ::xml_schema::string&);

    comparisson_attibute (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    comparisson_attibute (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    comparisson_attibute (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    comparisson_attibute (const comparisson_attibute& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual comparisson_attibute*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~comparisson_attibute ();
  };

  class unit: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    unit ();

    unit (const char*);

    unit (const ::std::string&);

    unit (const ::xml_schema::string&);

    unit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    unit (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    unit (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    unit (const unit& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual unit*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~unit ();
  };

  class lower: public ::xml_schema::type
  {
    public:
    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // if
    // 
    typedef ::AdaptationPolicy::IFType if_type;
    typedef ::xsd::cxx::tree::sequence< if_type > if_sequence;
    typedef if_sequence::iterator if_iterator;
    typedef if_sequence::const_iterator if_const_iterator;
    typedef ::xsd::cxx::tree::traits< if_type, char > if_traits;

    const if_sequence&
    if_ () const;

    if_sequence&
    if_ ();

    void
    if_ (const if_sequence& s);

    // threshold
    // 
    typedef ::xml_schema::float_ threshold_type;
    typedef ::xsd::cxx::tree::traits< threshold_type, char > threshold_traits;

    const threshold_type&
    threshold () const;

    threshold_type&
    threshold ();

    void
    threshold (const threshold_type& x);

    // Constructors.
    //
    lower (const threshold_type&);

    lower (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    lower (const lower& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual lower*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~lower ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    complexproperty_sequence complexproperty_;
    simpleproperty_sequence simpleproperty_;
    if_sequence if__;
    ::xsd::cxx::tree::one< threshold_type > threshold_;
  };

  class range: public ::xml_schema::type
  {
    public:
    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // if
    // 
    typedef ::AdaptationPolicy::IFType if_type;
    typedef ::xsd::cxx::tree::sequence< if_type > if_sequence;
    typedef if_sequence::iterator if_iterator;
    typedef if_sequence::const_iterator if_const_iterator;
    typedef ::xsd::cxx::tree::traits< if_type, char > if_traits;

    const if_sequence&
    if_ () const;

    if_sequence&
    if_ ();

    void
    if_ (const if_sequence& s);

    // from
    // 
    typedef ::xml_schema::float_ from_type;
    typedef ::xsd::cxx::tree::traits< from_type, char > from_traits;

    const from_type&
    from () const;

    from_type&
    from ();

    void
    from (const from_type& x);

    // to
    // 
    typedef ::xml_schema::float_ to_type;
    typedef ::xsd::cxx::tree::traits< to_type, char > to_traits;

    const to_type&
    to () const;

    to_type&
    to ();

    void
    to (const to_type& x);

    // Constructors.
    //
    range (const from_type&,
           const to_type&);

    range (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    range (const range& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual range*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~range ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    complexproperty_sequence complexproperty_;
    simpleproperty_sequence simpleproperty_;
    if_sequence if__;
    ::xsd::cxx::tree::one< from_type > from_;
    ::xsd::cxx::tree::one< to_type > to_;
  };

  class greater: public ::xml_schema::type
  {
    public:
    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // if
    // 
    typedef ::AdaptationPolicy::IFType if_type;
    typedef ::xsd::cxx::tree::sequence< if_type > if_sequence;
    typedef if_sequence::iterator if_iterator;
    typedef if_sequence::const_iterator if_const_iterator;
    typedef ::xsd::cxx::tree::traits< if_type, char > if_traits;

    const if_sequence&
    if_ () const;

    if_sequence&
    if_ ();

    void
    if_ (const if_sequence& s);

    // threshold
    // 
    typedef ::xml_schema::float_ threshold_type;
    typedef ::xsd::cxx::tree::traits< threshold_type, char > threshold_traits;

    const threshold_type&
    threshold () const;

    threshold_type&
    threshold ();

    void
    threshold (const threshold_type& x);

    // Constructors.
    //
    greater (const threshold_type&);

    greater (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    greater (const greater& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual greater*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~greater ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    complexproperty_sequence complexproperty_;
    simpleproperty_sequence simpleproperty_;
    if_sequence if__;
    ::xsd::cxx::tree::one< threshold_type > threshold_;
  };

  class key: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    key ();

    key (const char*);

    key (const ::std::string&);

    key (const ::xml_schema::string&);

    key (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    key (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    key (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    key (const key& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual key*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~key ();
  };

  class key1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    key1 ();

    key1 (const char*);

    key1 (const ::std::string&);

    key1 (const ::xml_schema::string&);

    key1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    key1 (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    key1 (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    key1 (const key1& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual key1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~key1 ();
  };

  class equals: public ::xml_schema::type
  {
    public:
    // Lhs
    // 
    typedef ::xml_schema::string Lhs_type;
    typedef ::xsd::cxx::tree::traits< Lhs_type, char > Lhs_traits;

    const Lhs_type&
    Lhs () const;

    Lhs_type&
    Lhs ();

    void
    Lhs (const Lhs_type& x);

    void
    Lhs (::std::auto_ptr< Lhs_type > p);

    // Rhs
    // 
    typedef ::xml_schema::float_ Rhs_type;
    typedef ::xsd::cxx::tree::traits< Rhs_type, char > Rhs_traits;

    const Rhs_type&
    Rhs () const;

    Rhs_type&
    Rhs ();

    void
    Rhs (const Rhs_type& x);

    // Constructors.
    //
    equals (const Lhs_type&,
            const Rhs_type&);

    equals (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    equals (const equals& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual equals*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~equals ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Lhs_type > Lhs_;
    ::xsd::cxx::tree::one< Rhs_type > Rhs_;
  };

  class lower1: public ::xml_schema::type
  {
    public:
    // Lhs
    // 
    typedef ::xml_schema::string Lhs_type;
    typedef ::xsd::cxx::tree::traits< Lhs_type, char > Lhs_traits;

    const Lhs_type&
    Lhs () const;

    Lhs_type&
    Lhs ();

    void
    Lhs (const Lhs_type& x);

    void
    Lhs (::std::auto_ptr< Lhs_type > p);

    // Rhs
    // 
    typedef ::xml_schema::float_ Rhs_type;
    typedef ::xsd::cxx::tree::traits< Rhs_type, char > Rhs_traits;

    const Rhs_type&
    Rhs () const;

    Rhs_type&
    Rhs ();

    void
    Rhs (const Rhs_type& x);

    // equals
    // 
    typedef ::xml_schema::boolean equals_type;
    typedef ::xsd::cxx::tree::traits< equals_type, char > equals_traits;

    const equals_type&
    equals () const;

    equals_type&
    equals ();

    void
    equals (const equals_type& x);

    static const equals_type&
    equals_default_value ();

    // Constructors.
    //
    lower1 (const Lhs_type&,
            const Rhs_type&);

    lower1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    lower1 (const lower1& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual lower1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~lower1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Lhs_type > Lhs_;
    ::xsd::cxx::tree::one< Rhs_type > Rhs_;
    ::xsd::cxx::tree::one< equals_type > equals_;
    static const equals_type equals_default_value_;
  };

  class greater1: public ::xml_schema::type
  {
    public:
    // Lhs
    // 
    typedef ::xml_schema::string Lhs_type;
    typedef ::xsd::cxx::tree::traits< Lhs_type, char > Lhs_traits;

    const Lhs_type&
    Lhs () const;

    Lhs_type&
    Lhs ();

    void
    Lhs (const Lhs_type& x);

    void
    Lhs (::std::auto_ptr< Lhs_type > p);

    // Rhs
    // 
    typedef ::xml_schema::float_ Rhs_type;
    typedef ::xsd::cxx::tree::traits< Rhs_type, char > Rhs_traits;

    const Rhs_type&
    Rhs () const;

    Rhs_type&
    Rhs ();

    void
    Rhs (const Rhs_type& x);

    // equals
    // 
    typedef ::xml_schema::boolean equals_type;
    typedef ::xsd::cxx::tree::traits< equals_type, char > equals_traits;

    const equals_type&
    equals () const;

    equals_type&
    equals ();

    void
    equals (const equals_type& x);

    static const equals_type&
    equals_default_value ();

    // Constructors.
    //
    greater1 (const Lhs_type&,
              const Rhs_type&);

    greater1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    greater1 (const greater1& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual greater1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~greater1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< Lhs_type > Lhs_;
    ::xsd::cxx::tree::one< Rhs_type > Rhs_;
    ::xsd::cxx::tree::one< equals_type > equals_;
    static const equals_type equals_default_value_;
  };

  class operations: public ::xml_schema::type
  {
    public:
    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // Constructors.
    //
    operations ();

    operations (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    operations (const operations& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual operations*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~operations ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    simpleproperty_sequence simpleproperty_;
    complexproperty_sequence complexproperty_;
  };

  class negotiation: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    negotiation ();

    negotiation (const char*);

    negotiation (const ::std::string&);

    negotiation (const ::xml_schema::string&);

    negotiation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    negotiation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    negotiation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    negotiation (const negotiation& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual negotiation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~negotiation ();
  };

  class transport: public ::xml_schema::type
  {
    public:
    // protocol
    // 
    typedef ::AdaptationPolicy::protocol protocol_type;
    typedef ::xsd::cxx::tree::traits< protocol_type, char > protocol_traits;

    const protocol_type&
    protocol () const;

    protocol_type&
    protocol ();

    void
    protocol (const protocol_type& x);

    void
    protocol (::std::auto_ptr< protocol_type > p);

    // plugin-name
    // 
    typedef ::AdaptationPolicy::plugin_name plugin_name_type;
    typedef ::xsd::cxx::tree::traits< plugin_name_type, char > plugin_name_traits;

    const plugin_name_type&
    plugin_name () const;

    plugin_name_type&
    plugin_name ();

    void
    plugin_name (const plugin_name_type& x);

    void
    plugin_name (::std::auto_ptr< plugin_name_type > p);

    // library-name
    // 
    typedef ::AdaptationPolicy::library_name library_name_type;
    typedef ::xsd::cxx::tree::traits< library_name_type, char > library_name_traits;

    const library_name_type&
    library_name () const;

    library_name_type&
    library_name ();

    void
    library_name (const library_name_type& x);

    void
    library_name (::std::auto_ptr< library_name_type > p);

    // library-directory
    // 
    typedef ::AdaptationPolicy::library_directory library_directory_type;
    typedef ::xsd::cxx::tree::optional< library_directory_type > library_directory_optional;
    typedef ::xsd::cxx::tree::traits< library_directory_type, char > library_directory_traits;

    const library_directory_optional&
    library_directory () const;

    library_directory_optional&
    library_directory ();

    void
    library_directory (const library_directory_type& x);

    void
    library_directory (const library_directory_optional& x);

    void
    library_directory (::std::auto_ptr< library_directory_type > p);

    // enable-adaptation
    // 
    typedef ::xml_schema::boolean enable_adaptation_type;
    typedef ::xsd::cxx::tree::traits< enable_adaptation_type, char > enable_adaptation_traits;

    const enable_adaptation_type&
    enable_adaptation () const;

    enable_adaptation_type&
    enable_adaptation ();

    void
    enable_adaptation (const enable_adaptation_type& x);

    static const enable_adaptation_type&
    enable_adaptation_default_value ();

    // provides
    // 
    typedef ::AdaptationPolicy::provides provides_type;
    typedef ::xsd::cxx::tree::optional< provides_type > provides_optional;
    typedef ::xsd::cxx::tree::traits< provides_type, char > provides_traits;

    const provides_optional&
    provides () const;

    provides_optional&
    provides ();

    void
    provides (const provides_type& x);

    void
    provides (const provides_optional& x);

    void
    provides (::std::auto_ptr< provides_type > p);

    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // Constructors.
    //
    transport (const protocol_type&,
               const plugin_name_type&,
               const library_name_type&,
               const enable_adaptation_type&);

    transport (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    transport (const transport& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual transport*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~transport ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< protocol_type > protocol_;
    ::xsd::cxx::tree::one< plugin_name_type > plugin_name_;
    ::xsd::cxx::tree::one< library_name_type > library_name_;
    library_directory_optional library_directory_;
    ::xsd::cxx::tree::one< enable_adaptation_type > enable_adaptation_;
    static const enable_adaptation_type enable_adaptation_default_value_;
    provides_optional provides_;
    complexproperty_sequence complexproperty_;
    simpleproperty_sequence simpleproperty_;
  };

  class stream: public ::xml_schema::type
  {
    public:
    // plugin-name
    // 
    typedef ::AdaptationPolicy::plugin_name1 plugin_name_type;
    typedef ::xsd::cxx::tree::traits< plugin_name_type, char > plugin_name_traits;

    const plugin_name_type&
    plugin_name () const;

    plugin_name_type&
    plugin_name ();

    void
    plugin_name (const plugin_name_type& x);

    void
    plugin_name (::std::auto_ptr< plugin_name_type > p);

    // library-name
    // 
    typedef ::AdaptationPolicy::library_name1 library_name_type;
    typedef ::xsd::cxx::tree::traits< library_name_type, char > library_name_traits;

    const library_name_type&
    library_name () const;

    library_name_type&
    library_name ();

    void
    library_name (const library_name_type& x);

    void
    library_name (::std::auto_ptr< library_name_type > p);

    // library-directory
    // 
    typedef ::AdaptationPolicy::library_directory1 library_directory_type;
    typedef ::xsd::cxx::tree::optional< library_directory_type > library_directory_optional;
    typedef ::xsd::cxx::tree::traits< library_directory_type, char > library_directory_traits;

    const library_directory_optional&
    library_directory () const;

    library_directory_optional&
    library_directory ();

    void
    library_directory (const library_directory_type& x);

    void
    library_directory (const library_directory_optional& x);

    void
    library_directory (::std::auto_ptr< library_directory_type > p);

    // transmission-properties
    // 
    typedef ::AdaptationPolicy::transmission_properties transmission_properties_type;
    typedef ::xsd::cxx::tree::traits< transmission_properties_type, char > transmission_properties_traits;

    const transmission_properties_type&
    transmission_properties () const;

    transmission_properties_type&
    transmission_properties ();

    void
    transmission_properties (const transmission_properties_type& x);

    void
    transmission_properties (::std::auto_ptr< transmission_properties_type > p);

    // enable-adaptation
    // 
    typedef ::xml_schema::boolean enable_adaptation_type;
    typedef ::xsd::cxx::tree::traits< enable_adaptation_type, char > enable_adaptation_traits;

    const enable_adaptation_type&
    enable_adaptation () const;

    enable_adaptation_type&
    enable_adaptation ();

    void
    enable_adaptation (const enable_adaptation_type& x);

    static const enable_adaptation_type&
    enable_adaptation_default_value ();

    // provides
    // 
    typedef ::AdaptationPolicy::provides1 provides_type;
    typedef ::xsd::cxx::tree::optional< provides_type > provides_optional;
    typedef ::xsd::cxx::tree::traits< provides_type, char > provides_traits;

    const provides_optional&
    provides () const;

    provides_optional&
    provides ();

    void
    provides (const provides_type& x);

    void
    provides (const provides_optional& x);

    void
    provides (::std::auto_ptr< provides_type > p);

    // complexproperty
    // 
    typedef ::AdaptationPolicy::ComplexPropertyType complexproperty_type;
    typedef ::xsd::cxx::tree::sequence< complexproperty_type > complexproperty_sequence;
    typedef complexproperty_sequence::iterator complexproperty_iterator;
    typedef complexproperty_sequence::const_iterator complexproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< complexproperty_type, char > complexproperty_traits;

    const complexproperty_sequence&
    complexproperty () const;

    complexproperty_sequence&
    complexproperty ();

    void
    complexproperty (const complexproperty_sequence& s);

    // simpleproperty
    // 
    typedef ::AdaptationPolicy::SimplePropertyType simpleproperty_type;
    typedef ::xsd::cxx::tree::sequence< simpleproperty_type > simpleproperty_sequence;
    typedef simpleproperty_sequence::iterator simpleproperty_iterator;
    typedef simpleproperty_sequence::const_iterator simpleproperty_const_iterator;
    typedef ::xsd::cxx::tree::traits< simpleproperty_type, char > simpleproperty_traits;

    const simpleproperty_sequence&
    simpleproperty () const;

    simpleproperty_sequence&
    simpleproperty ();

    void
    simpleproperty (const simpleproperty_sequence& s);

    // Constructors.
    //
    stream (const plugin_name_type&,
            const library_name_type&,
            const transmission_properties_type&,
            const enable_adaptation_type&);

    stream (const plugin_name_type&,
            const library_name_type&,
            ::std::auto_ptr< transmission_properties_type >&,
            const enable_adaptation_type&);

    stream (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    stream (const stream& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual stream*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~stream ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< plugin_name_type > plugin_name_;
    ::xsd::cxx::tree::one< library_name_type > library_name_;
    library_directory_optional library_directory_;
    ::xsd::cxx::tree::one< transmission_properties_type > transmission_properties_;
    ::xsd::cxx::tree::one< enable_adaptation_type > enable_adaptation_;
    static const enable_adaptation_type enable_adaptation_default_value_;
    provides_optional provides_;
    complexproperty_sequence complexproperty_;
    simpleproperty_sequence simpleproperty_;
  };

  class stream1: public ::xml_schema::type
  {
    public:
    // adaptation-method
    // 
    typedef ::AdaptationPolicy::adaptation_method adaptation_method_type;
    typedef ::xsd::cxx::tree::traits< adaptation_method_type, char > adaptation_method_traits;

    const adaptation_method_type&
    adaptation_method () const;

    adaptation_method_type&
    adaptation_method ();

    void
    adaptation_method (const adaptation_method_type& x);

    void
    adaptation_method (::std::auto_ptr< adaptation_method_type > p);

    // policy
    // 
    typedef ::AdaptationPolicy::PolicyType policy_type;
    typedef ::xsd::cxx::tree::sequence< policy_type > policy_sequence;
    typedef policy_sequence::iterator policy_iterator;
    typedef policy_sequence::const_iterator policy_const_iterator;
    typedef ::xsd::cxx::tree::traits< policy_type, char > policy_traits;

    const policy_sequence&
    policy () const;

    policy_sequence&
    policy ();

    void
    policy (const policy_sequence& s);

    // Constructors.
    //
    stream1 (const adaptation_method_type&);

    stream1 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    stream1 (const stream1& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual stream1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~stream1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< adaptation_method_type > adaptation_method_;
    policy_sequence policy_;
  };

  class transport1: public ::xml_schema::type
  {
    public:
    // adaptation-method
    // 
    typedef ::AdaptationPolicy::adaptation_method1 adaptation_method_type;
    typedef ::xsd::cxx::tree::traits< adaptation_method_type, char > adaptation_method_traits;

    const adaptation_method_type&
    adaptation_method () const;

    adaptation_method_type&
    adaptation_method ();

    void
    adaptation_method (const adaptation_method_type& x);

    void
    adaptation_method (::std::auto_ptr< adaptation_method_type > p);

    // policy
    // 
    typedef ::AdaptationPolicy::PolicyType policy_type;
    typedef ::xsd::cxx::tree::sequence< policy_type > policy_sequence;
    typedef policy_sequence::iterator policy_iterator;
    typedef policy_sequence::const_iterator policy_const_iterator;
    typedef ::xsd::cxx::tree::traits< policy_type, char > policy_traits;

    const policy_sequence&
    policy () const;

    policy_sequence&
    policy ();

    void
    policy (const policy_sequence& s);

    // Constructors.
    //
    transport1 (const adaptation_method_type&);

    transport1 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    transport1 (const transport1& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual transport1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~transport1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< adaptation_method_type > adaptation_method_;
    policy_sequence policy_;
  };

  class protocol: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    protocol ();

    protocol (const char*);

    protocol (const ::std::string&);

    protocol (const ::xml_schema::string&);

    protocol (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    protocol (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    protocol (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    protocol (const protocol& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual protocol*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~protocol ();
  };

  class plugin_name: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    plugin_name ();

    plugin_name (const char*);

    plugin_name (const ::std::string&);

    plugin_name (const ::xml_schema::string&);

    plugin_name (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    plugin_name (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    plugin_name (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    plugin_name (const plugin_name& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual plugin_name*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~plugin_name ();
  };

  class library_name: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    library_name ();

    library_name (const char*);

    library_name (const ::std::string&);

    library_name (const ::xml_schema::string&);

    library_name (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    library_name (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    library_name (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    library_name (const library_name& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual library_name*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~library_name ();
  };

  class library_directory: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    library_directory ();

    library_directory (const char*);

    library_directory (const ::std::string&);

    library_directory (const ::xml_schema::string&);

    library_directory (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    library_directory (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    library_directory (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    library_directory (const library_directory& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual library_directory*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~library_directory ();
  };

  class provides: public ::xml_schema::type
  {
    public:
    // provide
    // 
    typedef ::AdaptationPolicy::ProviderType provide_type;
    typedef ::xsd::cxx::tree::sequence< provide_type > provide_sequence;
    typedef provide_sequence::iterator provide_iterator;
    typedef provide_sequence::const_iterator provide_const_iterator;
    typedef ::xsd::cxx::tree::traits< provide_type, char > provide_traits;

    const provide_sequence&
    provide () const;

    provide_sequence&
    provide ();

    void
    provide (const provide_sequence& s);

    // Constructors.
    //
    provides ();

    provides (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    provides (const provides& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual provides*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~provides ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    provide_sequence provide_;
  };

  class plugin_name1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    plugin_name1 ();

    plugin_name1 (const char*);

    plugin_name1 (const ::std::string&);

    plugin_name1 (const ::xml_schema::string&);

    plugin_name1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    plugin_name1 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    plugin_name1 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    plugin_name1 (const plugin_name1& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual plugin_name1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~plugin_name1 ();
  };

  class library_name1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    library_name1 ();

    library_name1 (const char*);

    library_name1 (const ::std::string&);

    library_name1 (const ::xml_schema::string&);

    library_name1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    library_name1 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    library_name1 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    library_name1 (const library_name1& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual library_name1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~library_name1 ();
  };

  class library_directory1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    library_directory1 ();

    library_directory1 (const char*);

    library_directory1 (const ::std::string&);

    library_directory1 (const ::xml_schema::string&);

    library_directory1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    library_directory1 (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    library_directory1 (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    library_directory1 (const library_directory1& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual library_directory1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~library_directory1 ();
  };

  class transmission_properties: public ::xml_schema::type
  {
    public:
    // video-transmission
    // 
    typedef ::AdaptationPolicy::video_transmission video_transmission_type;
    typedef ::xsd::cxx::tree::optional< video_transmission_type > video_transmission_optional;
    typedef ::xsd::cxx::tree::traits< video_transmission_type, char > video_transmission_traits;

    const video_transmission_optional&
    video_transmission () const;

    video_transmission_optional&
    video_transmission ();

    void
    video_transmission (const video_transmission_type& x);

    void
    video_transmission (const video_transmission_optional& x);

    void
    video_transmission (::std::auto_ptr< video_transmission_type > p);

    // audio-transmission
    // 
    typedef ::AdaptationPolicy::audio_transmission audio_transmission_type;
    typedef ::xsd::cxx::tree::optional< audio_transmission_type > audio_transmission_optional;
    typedef ::xsd::cxx::tree::traits< audio_transmission_type, char > audio_transmission_traits;

    const audio_transmission_optional&
    audio_transmission () const;

    audio_transmission_optional&
    audio_transmission ();

    void
    audio_transmission (const audio_transmission_type& x);

    void
    audio_transmission (const audio_transmission_optional& x);

    void
    audio_transmission (::std::auto_ptr< audio_transmission_type > p);

    // transmission-type
    // 
    typedef ::AdaptationPolicy::transmission_type transmission_type_type;
    typedef ::xsd::cxx::tree::traits< transmission_type_type, char > transmission_type_traits;

    const transmission_type_type&
    transmission_type () const;

    transmission_type_type&
    transmission_type ();

    void
    transmission_type (const transmission_type_type& x);

    void
    transmission_type (::std::auto_ptr< transmission_type_type > p);

    static const transmission_type_type&
    transmission_type_default_value ();

    // Constructors.
    //
    transmission_properties ();

    transmission_properties (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    transmission_properties (const transmission_properties& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual transmission_properties*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~transmission_properties ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    video_transmission_optional video_transmission_;
    audio_transmission_optional audio_transmission_;
    ::xsd::cxx::tree::one< transmission_type_type > transmission_type_;
    static const transmission_type_type transmission_type_default_value_;
  };

  class provides1: public ::xml_schema::type
  {
    public:
    // provide
    // 
    typedef ::AdaptationPolicy::ProviderType provide_type;
    typedef ::xsd::cxx::tree::sequence< provide_type > provide_sequence;
    typedef provide_sequence::iterator provide_iterator;
    typedef provide_sequence::const_iterator provide_const_iterator;
    typedef ::xsd::cxx::tree::traits< provide_type, char > provide_traits;

    const provide_sequence&
    provide () const;

    provide_sequence&
    provide ();

    void
    provide (const provide_sequence& s);

    // Constructors.
    //
    provides1 ();

    provides1 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    provides1 (const provides1& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual provides1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~provides1 ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    provide_sequence provide_;
  };

  class adaptation_method: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    adaptation_method ();

    adaptation_method (const char*);

    adaptation_method (const ::std::string&);

    adaptation_method (const ::xml_schema::string&);

    adaptation_method (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    adaptation_method (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    adaptation_method (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    adaptation_method (const adaptation_method& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual adaptation_method*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~adaptation_method ();
  };

  class adaptation_method1: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    adaptation_method1 ();

    adaptation_method1 (const char*);

    adaptation_method1 (const ::std::string&);

    adaptation_method1 (const ::xml_schema::string&);

    adaptation_method1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    adaptation_method1 (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    adaptation_method1 (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    adaptation_method1 (const adaptation_method1& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual adaptation_method1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~adaptation_method1 ();
  };

  class video_transmission: public ::xml_schema::type
  {
    public:
    // video-codec
    // 
    typedef ::xml_schema::string video_codec_type;
    typedef ::xsd::cxx::tree::traits< video_codec_type, char > video_codec_traits;

    const video_codec_type&
    video_codec () const;

    video_codec_type&
    video_codec ();

    void
    video_codec (const video_codec_type& x);

    void
    video_codec (::std::auto_ptr< video_codec_type > p);

    // Constructors.
    //
    video_transmission (const video_codec_type&);

    video_transmission (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    video_transmission (const video_transmission& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual video_transmission*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~video_transmission ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< video_codec_type > video_codec_;
  };

  class audio_transmission: public ::xml_schema::type
  {
    public:
    // codec-name
    // 
    typedef ::AdaptationPolicy::codec_name codec_name_type;
    typedef ::xsd::cxx::tree::traits< codec_name_type, char > codec_name_traits;

    const codec_name_type&
    codec_name () const;

    codec_name_type&
    codec_name ();

    void
    codec_name (const codec_name_type& x);

    void
    codec_name (::std::auto_ptr< codec_name_type > p);

    // enable-preprocessing
    // 
    typedef ::xml_schema::boolean enable_preprocessing_type;
    typedef ::xsd::cxx::tree::traits< enable_preprocessing_type, char > enable_preprocessing_traits;

    const enable_preprocessing_type&
    enable_preprocessing () const;

    enable_preprocessing_type&
    enable_preprocessing ();

    void
    enable_preprocessing (const enable_preprocessing_type& x);

    static const enable_preprocessing_type&
    enable_preprocessing_default_value ();

    // Constructors.
    //
    audio_transmission (const codec_name_type&);

    audio_transmission (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    audio_transmission (const audio_transmission& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual audio_transmission*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~audio_transmission ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< codec_name_type > codec_name_;
    ::xsd::cxx::tree::one< enable_preprocessing_type > enable_preprocessing_;
    static const enable_preprocessing_type enable_preprocessing_default_value_;
  };

  class transmission_type: public ::xml_schema::string
  {
    public:
    enum value
    {
      half_transmit,
      half_receive,
      full_duplex
    };

    transmission_type (value v);

    transmission_type (const char* v);

    transmission_type (const ::std::string& v);

    transmission_type (const ::xml_schema::string& v);

    transmission_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    transmission_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    transmission_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    transmission_type (const transmission_type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual transmission_type*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    transmission_type&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_transmission_type_convert ();
    }

    protected:
    value
    _xsd_transmission_type_convert () const;

    public:
    static const char* const _xsd_transmission_type_literals_[3];
    static const value _xsd_transmission_type_indexes_[3];
  };

  class codec_name: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    codec_name ();

    codec_name (const char*);

    codec_name (const ::std::string&);

    codec_name (const ::xml_schema::string&);

    codec_name (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    codec_name (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    codec_name (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    codec_name (const codec_name& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual codec_name*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~codec_name ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace AdaptationPolicy
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& uri,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& uri,
                     ::xml_schema::error_handler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::std::string& uri,
                     ::xercesc::DOMErrorHandler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xml_schema::error_handler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     ::xercesc::DOMErrorHandler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& id,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& id,
                     ::xml_schema::error_handler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::std::istream& is,
                     const ::std::string& id,
                     ::xercesc::DOMErrorHandler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& is,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& is,
                     ::xml_schema::error_handler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xercesc::InputSource& is,
                     ::xercesc::DOMErrorHandler& eh,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::AdaptationPolicy::PolicyConfigurationType >
  adaptation_policy (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f = 0,
                     const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // POLICY_HXX
